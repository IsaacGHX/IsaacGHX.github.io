[{"title":"Temporary Linux Python Working Direction","url":"/2025/07/03/fast_startup/Temporary-Linux-Python-Execution-Direction/","content":"How to Quickly Set Current Directory as Python’s Working Directory in LinuxTo enable Python in a Linux environment to directly import modules from the current directory, the most common and recommended approach is to modify the Python module search path. Below are several common methods, along with their pros and cons.\n\n1. Temporarily Modifying the [$PYTHONPATH] Environment Variable (Recommended)This is the most common and flexible method, as it only affects the current session or script execution.\nIn your terminal, navigate to the directory containing your Python modules, then run:\nexport PYTHONPATH=$(pwd)\nExplanation:\n\nexport PYTHONPATH: This Linux command is used to set or modify the PYTHONPATH environment variable. Python checks the paths defined in this variable when searching for modules.\n$(pwd): This is a command substitution; the pwd command outputs the absolute path of the current working directory. $(pwd) uses its output as an argument for the export command.\n\nExample:\nAssume your file structure is like this:\nmy_project/├── main.py└── my_module.py\nmy_module.py content:\ndef hello():    print(&quot;Hello from my_module!&quot;)\nmain.py content:\nimport my_modulemy_module.hello()\n\nEnter the my_project directory:cd my_project\nSet PYTHONPATH:export PYTHONPATH=$(pwd)\nRun main.py:python main.py\nYou should see the output “Hello from my_module!“\n\nPros:\n\nNon-invasive: Only effective for the current terminal session or script, does not permanently alter system configuration.\nFlexible: Suitable for any scenario requiring temporary path additions.\n\nCons:\n\nNeeds to be set again every time you open a new terminal session.\n\n\n2. Adding Path via [sys.path.append()] in Python ScriptYou can also directly add the current directory to the module search path at the beginning of your Python script.\nimport sysimport os# Add the directory containing the current script to Python&#x27;s search path# os.path.dirname(__file__) gets the directory of the current script# os.path.abspath() gets the absolute pathcurrent_dir = os.path.abspath(os.path.dirname(__file__))if current_dir not in sys.path:    sys.path.append(current_dir)# Now you can import modules from the current directoryimport your_module_name\nPros:\n\nSelf-contained: Handled automatically when the script runs, no external commands needed.\nPortable: The script can run in any environment without additional setup.\n\nCons:\n\nRequires adding this code to every script that needs this functionality.\nIf modules are in subdirectories of the current directory, it requires more complex path handling.\n\n\n3. Using the [-m] Option (for Executable Modules/Packages)If your Python structure is an executable package, you can use the -m option to run a module. This automatically handles module path issues.\nFor example, if your my_project structure looks like this:\nmy_project/├── __init__.py└── my_script.py\nAnd you want to run my_script.py:\npython -m my_project.my_script\nPros:\n\nSuitable for building executable packages.\nPython handles paths automatically.\n\nCons:\n\nRequires your code to be organized as a Python package (i.e., include an __init__.py file).\n\n\nSummaryFor most temporary development and testing scenarios, the first method (export PYTHONPATH=$(pwd)) is the most concise and recommended. It allows you to run Python scripts directly in the current directory and import sibling modules without modifying the script itself.\nIf you need a more robust solution, such as building a large project, it’s typically recommended to use a Python package structure and manage module dependencies and paths via pip install -e . (editable install) or by building a setup.py file.\n","tags":["ENV"]},{"title":"V-PS VLESS-REALITY 代理部署与客户端配置指南","url":"/2025/07/07/fast_startup/V-PS-VLESS-REALITY-%E4%BB%A3%E7%90%86%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","content":"远程服务器 VLESS-REALITY 代理部署与客户端配置指南本文档将指导您完成以下全部流程：\n\n在 AWS Lightsail VPS 上进行基础设置和安全加固。\n部署 Xray-core 并配置 VLESS-REALITY 服务。\n在本地生成客户端所需的 YAML 配置文件。\n通过 GitHub Gist 发布配置文件，生成可供订阅的 HTTP 链接。\n提供一个一键生成本地 YAML 文件的脚本。\n\n\n1. 简介与准备工作1.1 VPS 推荐：AWS Lightsail对于需要稳定、高质量国际网络连接的学术和研究用途，AWS Lightsail 是一个优秀的选择。\n关键步骤：\n\n前往 AWS Lightsail官网 创建一个实例。推荐选择位于东京或新加坡等低延迟地区的实例。\n在实例的管理面板中，进入“网络”选项卡，务必创建一个静态 IP 地址并将其附加到您的实例。这是确保您的服务地址不会因重启而改变的关键。\n\n1.2 VLESS 与 REALITY 协议简述VLESS 是一个性能卓越、配置灵活的轻量级传输协议。它本身不包含加密，将加密的责任交给了底层传输层（如 TLS），实现了“权责分离”，从而获得了极高的性能和可扩展性。\nREALITY (REgular-expression based Application Layer proxy for Inbound TLSY) 是一种革命性的 TLS 代理技术。它通过“借用”一个真实、有效的目标网站的 TLS 证书来伪装流量，解决了传统代理需要购买域名和申请证书的痛点。当流量被审查时，它看起来就像是用户在直接访问一个普通的、知名的大型网站（例如 www.bing.com），从而为学术数据传输和网络研究提供了极佳的隐蔽性和稳定性。\n1.3 为什么不推荐使用 Cloudflare 代理？对于 VLESS-REALITY 这种旨在模仿真实用户直接访问目标网站的协议，不应该再套一层 Cloudflare 代理。原因如下：\n\n特征冲突：Cloudflare 的代理是为隐藏服务器真实 IP、抗 DDoS 等场景设计的，其流量特征（如特定的 TLS 指纹、IP段）非常明显。这与 REALITY 试图模仿直接连接的初衷相悖。\n显著增加延迟：所有流量都需要先经过 Cloudflare 的全球网络再到达您的服务器，相当于进行了一次不必要的中转。这会显著增加网络延迟（通常增加 30%-50% 或更高），降低连接速度和响应性。\n功能性问题：\n过多重定向：可能导致某些服务（如 cn.bing.com 的搜索）失败。\n人机验证失败：许多网站使用 Cloudflare 的服务来防御机器人，当您的代理流量也通过 Cloudflare 时，可能会触发更严格的人机验证，甚至无法通过。\n\n\n\n\n2. 服务器准备与安全加固2.1 更新系统通过 SSH 连接到您的服务器，并执行以下命令，确保所有软件包都是最新的。\nsudo apt update &amp;&amp; sudo apt upgrade -y\n2.2 防火墙加固 (UFW)我们将采用“默认拒绝”策略，只放行必要的端口。\n\n设置默认策略：\nsudo ufw default deny incomingsudo ufw default allow outgoing\n\n允许 SSH 和 Xray 端口：\n\n22 是默认 SSH 端口，443 是我们将要使用的 Xray 服务端口。\n重要：如果您计划修改 SSH 端口（强烈推荐），请务必先允许新端口，再禁用旧端口。例如，将 SSH 端口改为 7777。\n\n\n# 允许你自定义的SSH端口sudo ufw allow 7777/tcp# 允许 Xray 服务端口sudo ufw allow 443/tcp# 如果您确认新的SSH端口可以登录，可以禁用默认的22端口# sudo ufw deny 22/tcp\n\n注意：请务必检查云服务商（如 AWS Lightsail）自带的网络防火墙规则，确保上述端口（7777 和 443）也已对公网开放。为了省心，您可以选择允许所有 TCP/UDP 端口（0-65535）的流量，但这会降低安全性。\n\n\n启用并检查状态：\nsudo ufw enablesudo ufw status verbose\n当看到 Status: active 和您添加的规则列表时，表示防火墙已成功启动。\n\n\n2.3 (可选但强烈推荐) SSH 安全强化\n创建新用户并授予 sudo 权限：\n# 将 your_username 替换为您想用的用户名adduser your_usernameusermod -aG sudo your_username\n\n配置 SSH 密钥认证：\n\n在您自己的电脑上生成 SSH 密钥对。\n将公钥 (~/.ssh/id_rsa.pub 的内容) 复制到服务器上新用户的 ~/.ssh/authorized_keys 文件中。\n确保您能通过密钥免密登录新用户后，再进行下一步。\n\n\n修改 SSH 配置文件：\nsudo nano /etc/ssh/sshd_config\n找到并修改以下参数：\n# 将端口从 22 改为 1024-65535 之间的任意端口Port 7777# 禁止 root 用户远程登录PermitRootLogin no# 禁用密码认证，强制使用密钥登录PasswordAuthentication no\n\n检查云服务商的覆盖配置：检查 /etc/ssh/sshd_config.d/ 目录下是否有云服务商的配置文件（如 50-cloud-init.conf）。如果该文件强制 PasswordAuthentication yes，请将其修改为 no 或删除该文件。\n\n重启 SSH 服务：\nsudo systemctl restart ssh\n现在，您需要使用新的端口和密钥才能登录服务器。\n\n\n2.4 网络性能优化：启用 TCP BBRBBR 算法能显著改善长距离、高延迟网络下的连接速度和吞吐量。\n\n修改系统控制参数：\nsudo nano /etc/sysctl.conf\n在文件末尾添加以下两行：\nnet.core.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr\n\n应用并验证配置：\n# 使配置立即生效sudo sysctl -p# 验证 BBR 是否已启用sysctl net.ipv4.tcp_congestion_control\n如果输出结果为 net.ipv4.tcp_congestion_control = bbr，则表示配置成功。\n\n注意：一些云服务商（如 AWS Lightsail）默认就允许了，也是好事。\n\n\n\n\n3. 核心服务部署：Xray-core3.1 安装 Xray-core使用官方一键安装脚本来安装最新版本。\nbash -c &quot;$(curl -L [https://github.com/XTLS/Xray-install/raw/main/install-release.sh](https://github.com/XTLS/Xray-install/raw/main/install-release.sh))&quot; @ install\n3.2 生成必要凭证在配置前，我们需要生成一个 UUID 和一对 REALITY 密钥。\n\n生成 UUID：\n/usr/local/bin/xray uuid\n\n记录下这串唯一的字符串，例如 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。\n\n\n生成 REALITY 密钥对：\n/usr/local/bin/xray x25519\n\n这会同时输出 私钥 (PrivateKey) 和 公钥 (PublicKey)。请务必妥善保存这两个密钥。私钥用于服务器配置，公钥用于客户端配置。\n\n\n\n3.3 编写 config.json 配置文件使用以下内容完全替换 /usr/local/etc/xray/config.json 文件。\nsudo nano /usr/local/etc/xray/config.json\n完整配置示例 (config.json)：\n&#123;    &quot;log&quot;: &#123;        &quot;loglevel&quot;: &quot;warning&quot;    &#125;,    &quot;routing&quot;: &#123;        &quot;domainStrategy&quot;: &quot;IPIfNonMatch&quot;,        &quot;rules&quot;: [            &#123;                &quot;type&quot;: &quot;field&quot;,                &quot;ip&quot;: [&quot;geoip:private&quot;],                &quot;outboundTag&quot;: &quot;block&quot;            &#125;,            &#123;                &quot;type&quot;: &quot;field&quot;,                &quot;protocol&quot;: [&quot;bittorrent&quot;],                &quot;outboundTag&quot;: &quot;block&quot;            &#125;        ]    &#125;,    &quot;inbounds&quot;: [        &#123;            &quot;port&quot;: 443,            &quot;protocol&quot;: &quot;vless&quot;,            &quot;settings&quot;: &#123;                &quot;clients&quot;: [                    &#123;                        &quot;id&quot;: &quot;your_uuid_here&quot;, // &lt;--- 替换为您生成的 UUID                        &quot;level&quot;: 0,                        &quot;flow&quot;: &quot;xtls-rprx-vision&quot;                    &#125;                ],                &quot;decryption&quot;: &quot;none&quot;            &#125;,            &quot;streamSettings&quot;: &#123;                &quot;network&quot;: &quot;tcp&quot;,                &quot;security&quot;: &quot;reality&quot;,                &quot;realitySettings&quot;: &#123;                    &quot;show&quot;: false,                    &quot;dest&quot;: &quot;[www.bing.com:443](https://www.bing.com:443)&quot;, // &lt;--- 伪装的目标网站，可自行更换                    &quot;xver&quot;: 0,                    &quot;serverNames&quot;: [                        &quot;[www.bing.com](https://www.bing.com)&quot;,         // &lt;--- 必须与 dest 网站证书上的域名匹配                        &quot;bing.com&quot;                    ],                    &quot;privateKey&quot;: &quot;your_private_key_here&quot;, // &lt;--- 粘贴您生成的 PrivateKey                    &quot;maxTimeDiff&quot;: 60000,                    &quot;shortIds&quot;: [                        &quot;&quot;,                        &quot;abcdef0123456789&quot; // &lt;--- 可自定义的 shortId，客户端需要使用                    ]                &#125;            &#125;,            &quot;sniffing&quot;: &#123;                &quot;enabled&quot;: true,                &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]            &#125;        &#125;    ],    &quot;outbounds&quot;: [        &#123;            &quot;protocol&quot;: &quot;freedom&quot;,            &quot;tag&quot;: &quot;direct&quot;        &#125;,        &#123;            &quot;protocol&quot;: &quot;blackhole&quot;,            &quot;tag&quot;: &quot;block&quot;        &#125;    ]&#125;\n配置说明：\n\nid: 替换为您自己生成的 UUID。\nprivateKey: 替换为您自己生成的私钥。\nshortIds: 这是一个 shortId 列表，客户端可以任选其一使用。你可以自定义一个，比如 abcdef0123456789。\ndest 和 serverNames: 这是 REALITY 的核心。dest 必须是一个墙外、支持 TLS 1.3 的稳定大网站。serverNames 必须包含 dest 网站证书上的域名。www.bing.com 是一个不错的选择。\n\n3.4 服务管理 (systemd)\n测试配置：\n/usr/local/bin/xray run -test -config /usr/local/etc/xray/config.json\n\n如果显示 Configuration OK，则表示配置无误。\n\n\n启动并设置开机自启：\nsudo systemctl restart xraysudo systemctl enable xray\n\n检查服务状态：\nsudo systemctl status xray\n\n确保服务状态是 active (running)。\n\n\n实时查看日志（用于排错）：\nsudo journalctl -u xray -f\n\n\n\n4. 客户端配置4.1 生成 YAML 代理片段您需要根据服务器上的配置，填写以下客户端 YAML 片段。\nproxies:- name: Catpaw-Tokyo-Reality # &lt;--- 节点名称，可自定义  type: vless  server: your_server_ip_here        # &lt;--- 替换为您的服务器静态IP地址  port: 443  uuid: your_uuid_here              # &lt;--- 替换为您的 UUID  network: tcp  tls: true  udp: true  flow: xtls-rprx-vision  servername: [www.bing.com](https://www.bing.com)          # &lt;--- 必须与服务器 config.json 中的 serverNames 之一完全匹配  reality-opts:    public-key: your_public_key_here  # &lt;--- 替换为您生成的 PublicKey    short-id: abcdef0123456789        # &lt;--- 替换为您在服务器上设置的 shortId  client-fingerprint: chrome\n4.2 使用 GitHub Gist 发布订阅文件\n登录 GitHub 并访问 gist.github.com。\n在文件名处输入 my_subscription.yaml。\n将一份完整的 Clash YAML 配置（例如文末脚本生成的内容）粘贴到代码框中。\n点击右下角的 Create secret gist。这会创建一个无法被搜索到的私密 Gist。\n创建成功后，点击页面右上角的 Raw 按钮。浏览器地址栏中的 URL 就是可以直接用于 Clash 客户端的订阅链接。\n\n\n5. 一键生成完整 YAML 配置文件脚本这个 shell 脚本会提示您输入必要信息，然后自动在当前目录下生成一个名为 config.yaml 的完整 Clash 配置文件。\n您可以将以下代码保存为一个名为 create_clash_config.sh 的文件。\n#!/bin/bash# ANSI Color CodesRED=&#x27;\\033[0;31m&#x27;GREEN=&#x27;\\033[0;32m&#x27;YELLOW=&#x27;\\033[1;33m&#x27;NC=&#x27;\\033[0m&#x27; # No Colorecho -e &quot;$&#123;GREEN&#125;--- Clash VLESS-REALITY YAML 动态配置生成脚本 ---$&#123;NC&#125;&quot;echo &quot;本脚本将引导您生成一份完整的 Clash 配置文件。&quot;echo &quot;&quot;# --- 获取用户输入 ---read -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[1/6] 请为您的代理节点命名 (例如: AWS-Tokyo-01): &#x27;$&#123;NC&#125;)&quot; PROXY_NAMEread -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[2/6] 请输入您的服务器 IP 地址: &#x27;$&#123;NC&#125;)&quot; SERVER_IPread -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[3/6] 请输入您在服务器config.json中设置的 servername (例如: www.bing.com): &#x27;$&#123;NC&#125;)&quot; SERVER_NAMEread -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[4/6] 请输入您的 UUID: &#x27;$&#123;NC&#125;)&quot; UUIDread -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[5/6] 请输入您的 REALITY PublicKey: &#x27;$&#123;NC&#125;)&quot; PUBLIC_KEYread -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;[6/6] 请输入您在服务器上设置的 short-id: &#x27;$&#123;NC&#125;)&quot; SHORT_ID# --- 检查输入 ---if [[ -z &quot;$PROXY_NAME&quot; || -z &quot;$SERVER_IP&quot; || -z &quot;$SERVER_NAME&quot; || -z &quot;$UUID&quot; || -z &quot;$PUBLIC_KEY&quot; || -z &quot;$SHORT_ID&quot; ]]; then    echo -e &quot;\\n$&#123;RED&#125;错误：所有字段均为必填项。脚本已中止，请重新运行。$&#123;NC&#125;&quot;    exit 1fi# --- 定义配置文件名 ---CONFIG_FILE=&quot;config.yaml&quot;# --- 使用 cat 和 EOF 创建 YAML 文件 ---# 使用用户输入的变量来填充模板cat &lt;&lt;EOF &gt; $&#123;CONFIG_FILE&#125;mixed-port: 7890mode: ruleipv6: falsegeodata-mode: truegeox-url:  geoip: https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.dat  geosite: https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geosite.dat  mmdb: https://fastly.jsdelivr.net/gh/MetaCubeX/meta-rules-dat@release/geoip.metadbgeo-auto-update: falsegeo-update-interval: 24log-level: infoglobal-client-fingerprint: chrometcp-concurrent: truefind-process-mode: strictunified-delay: trueprofile:  store-selected: true  store-fake-ip: truetun:  enable: false  stack: mixed  auto-route: true  auto-detect-interface: true  dns-hijack:  - any:53  - tcp://any:53sniffer:  enable: true  force-dns-mapping: true  parse-pure-ip: true  override-destination: true  sniff:    QUIC:      ports:      - 443      - 8443    TLS:      ports:      - 443      - 8443    HTTP:      ports:      - 80      - 8080-8880  force-domain:  - +.v2ex.com  skip-domain:  - Mijia Clouddns:  enable: true  respect-rules: false  listen: 0.0.0.0:1053  ipv6: false  default-nameserver:  - 223.5.5.5  - 119.29.29.29  enhanced-mode: fake-ip  fake-ip-range: 198.18.0.1/16  fake-ip-filter-mode: blacklist  fake-ip-filter:  - &#x27;*&#x27;  - +.lan  - +.local  - +.stun.*.*  - +.stun.*.*.*  - +.stun.*.*.*.*  - +.stun.*.*.*.*.*  nameserver:  - 223.5.5.5  - 119.29.29.29  fallback:  - tls://8.8.4.4  - tls://1.1.1.1  proxy-server-nameserver:  - https://223.5.5.5/dns-query  - https://1.12.12.12/dns-query  direct-nameserver:  - system  direct-nameserver-follow-policy: false  fallback-filter:    geoip: true    geoip-code: CN    nameserver-policy:      gfw    ipcidr:    - 240.0.0.0/4    domain:    - +.google.com    - +.facebook.com    - +.youtube.comproxies:- name: $&#123;PROXY_NAME&#125;  type: vless  server: $&#123;SERVER_IP&#125;  port: 443  uuid: $&#123;UUID&#125;  network: tcp  tls: true  udp: true  flow: xtls-rprx-vision  servername: $&#123;SERVER_NAME&#125;  reality-opts:    public-key: $&#123;PUBLIC_KEY&#125;    short-id: $&#123;SHORT_ID&#125;  client-fingerprint: chromeproxy-groups:- name: Proxy  type: select  proxies:  - $&#123;PROXY_NAME&#125;- name: AdBlock  type: select  proxies:  - REJECT  - DIRECTrule-providers:  reject:    type: http    behavior: domain    url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt    path: ./ruleset/reject.yaml    interval: 86400  proxy:    type: http    behavior: domain    url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt    path: ./ruleset/proxy.yaml    interval: 86400  gfw:    type: http    behavior: domain    url: https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt    path: ./ruleset/gfw.yaml    interval: 86400  steamCN:    type: http    behavior: classical    url: https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script@master/rule/Clash/SteamCN/SteamCN.yaml    path: ./ruleset/steamCN.yaml    interval: 86400  GameDownload:    type: http    behavior: classical    url: https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script@master/rule/Clash/Game/GameDownload/GameDownload.yaml    path: ./ruleset/GameDownload.yaml    interval: 86400  Bing:    type: http    behavior: classical    url: https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script@master/rule/Clash/Bing/Bing.yaml    path: ./ruleset/Bing.yaml    interval: 86400rules:- IP-CIDR,10.10.9.9/32,DIRECT- DOMAIN-SUFFIX,playerinfinite.com,Proxy- DOMAIN-SUFFIX,levelinfinite.com,Proxy- DOMAIN-SUFFIX,nodeseek.com,Proxy- RULE-SET,GameDownload,DIRECT- RULE-SET,steamCN,DIRECT- RULE-SET,reject,AdBlock- GEOSITE,category-ads,AdBlock- RULE-SET,gfw,Proxy- GEOSITE,cn,DIRECT- GEOIP,cn,DIRECT- MATCH,ProxyEOFecho &quot;&quot;echo -e &quot;$&#123;GREEN&#125;成功！配置文件 &#x27;$&#123;CONFIG_FILE&#125;&#x27; 已在当前目录生成。$&#123;NC&#125;&quot;echo &quot;它现在包含您自定义的节点名称和服务器信息。&quot;echo &quot;您可以直接在 Clash 客户端中导入此文件。&quot;\n如何使用此脚本：\n\n将上面的代码复制并粘贴到一个新文件中，例如 create_clash_config.sh。\n在您的终端中，给这个文件添加可执行权限：chmod +x create_clash_config.sh。\n运行脚本：./create_clash_config.sh。\n按照提示输入您的服务器IP、UUID、PublicKey 和 short-id。\n脚本执行完毕后，一个名为 config.yaml 的文件就会出现在当前目录下，您可以直接使用了。\n\n\n懒人包从一个新创建的、拥有 sudo 权限的用户开始，一键完成服务器环境配置、Xray 安装与配置，直到最后启动并验证服务。\n使用方法\n以您新创建的、拥有 sudo 权限的用户身份登录到您的服务器。\n将下面的代码完整复制，并粘贴到一个新文件中。例如，命名为 setup_xray.sh。nano setup_xray.sh# 粘贴代码，然后按 Ctrl+X, Y, Enter 保存退出\n给该脚本文件添加可执行权限：chmod +x setup_xray.sh\n运行脚本：./setup_xray.sh\n根据脚本的提示，输入所需信息并按回车键继续。\n\n\n一键部署脚本 (setup_xray.sh)#!/bin/bash# ==============================================================================#  Xray VLESS-REALITY 一键部署脚本 (适用于 Debian/Ubuntu)##  本脚本将执行以下操作:#  1. 更新系统软件包#  2. 配置 UFW 防火墙#  3. 启用 TCP BBR 网络优化#  4. 安装最新的 Xray-core#  5. 自动生成 REALITY 凭证并创建配置文件#  6. 启动并设置 Xray 开机自启# ==============================================================================# --- 全局变量和函数 ---# 颜色定义RED=&#x27;\\033[0;31m&#x27;GREEN=&#x27;\\033[0;32m&#x27;YELLOW=&#x27;\\033[1;33m&#x27;NC=&#x27;\\033[0m&#x27; # No Color# 使脚本在遇到错误时退出set -eset -o pipefail# 打印彩色消息print_color() &#123;    COLOR=$1    MESSAGE=$2    echo -e &quot;$&#123;COLOR&#125;$&#123;MESSAGE&#125;$&#123;NC&#125;&quot;&#125;# 暂停并等待用户按键press_any_key() &#123;    echo &quot;&quot;    print_color &quot;$YELLOW&quot; &quot;请按任意键继续...&quot;    read -n 1 -s -r    echo &quot;&quot;&#125;# 检查是否以 root 身份运行if [[ $(id -u) -eq 0 ]]; then    print_color &quot;$RED&quot; &quot;错误：请不要以 root 用户身份运行此脚本。请使用具有 sudo 权限的普通用户执行。&quot;    exit 1fi# --- 脚本主流程 ---clearprint_color &quot;$GREEN&quot; &quot;=======================================================&quot;print_color &quot;$GREEN&quot; &quot;      Xray VLESS-REALITY 服务器端一键部署脚本&quot;print_color &quot;$GREEN&quot; &quot;=======================================================&quot;echo &quot;&quot;print_color &quot;$YELLOW&quot; &quot;本脚本将引导您完成所有必要的服务器配置。&quot;press_any_key# --- 步骤 1: 系统更新 ---print_color &quot;$GREEN&quot; &quot;[1/5] 正在更新系统软件包...&quot;sudo apt update &amp;&amp; sudo apt upgrade -yprint_color &quot;$GREEN&quot; &quot;✅ 系统更新完成。&quot;press_any_key# --- 步骤 2: 配置防火墙 (UFW) ---print_color &quot;$GREEN&quot; &quot;[2/5] 正在配置 UFW 防火墙...&quot;read -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;请输入您当前使用的 SSH 端口 (默认为 22): &#x27;$&#123;NC&#125;)&quot; SSH_PORTSSH_PORT=$&#123;SSH_PORT:-22&#125;sudo ufw default deny incoming &gt;/dev/nullsudo ufw default allow outgoing &gt;/dev/nullsudo ufw allow $&#123;SSH_PORT&#125;/tcpsudo ufw allow 443/tcpsudo ufw --force enableprint_color &quot;$GREEN&quot; &quot;✅ 防火墙已启用并配置完成。当前规则:&quot;sudo ufw status verbosepress_any_key# --- 步骤 3: 启用 TCP BBR ---print_color &quot;$GREEN&quot; &quot;[3/5] 正在启用 TCP BBR 网络优化...&quot;&#123;    echo &quot;net.core.default_qdisc=fq&quot;    echo &quot;net.ipv4.tcp_congestion_control=bbr&quot;&#125; | sudo tee /etc/sysctl.d/99-bbr.conf &gt;/dev/nullsudo sysctl -p /etc/sysctl.d/99-bbr.conf &gt;/dev/nullif sysctl net.ipv4.tcp_congestion_control | grep -q &quot;bbr&quot;; then    print_color &quot;$GREEN&quot; &quot;✅ TCP BBR 已成功启用。&quot;else    print_color &quot;$RED&quot; &quot;❌ TCP BBR 启用失败，请检查内核版本（需 &gt;= 4.9）。&quot;fipress_any_key# --- 步骤 4: 安装 Xray-core ---print_color &quot;$GREEN&quot; &quot;[4/5] 正在安装最新的 Xray-core...&quot;sudo bash -c &quot;$(curl -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)&quot; @ install &gt;/dev/null 2&gt;&amp;1if [ -f &quot;/usr/local/bin/xray&quot; ]; then    print_color &quot;$GREEN&quot; &quot;✅ Xray-core 安装成功。&quot;else    print_color &quot;$RED&quot; &quot;❌ Xray-core 安装失败。&quot;    exit 1fipress_any_key# --- 步骤 5: 生成配置并启动服务 ---print_color &quot;$GREEN&quot; &quot;[5/5] 正在生成 Xray 配置文件并启动服务...&quot;# 交互式获取伪装域名print_color &quot;$YELLOW&quot; &quot;REALITY 需要一个真实存在的、支持 TLS 1.3 的目标网站进行伪装。&quot;read -p &quot;$(echo -e $&#123;YELLOW&#125;&#x27;请输入伪装域名 (默认为 www.bing.com): &#x27;$&#123;NC&#125;)&quot; FAKE_DEST_DOMAINFAKE_DEST_DOMAIN=$&#123;FAKE_DEST_DOMAIN:-&quot;www.bing.com&quot;&#125;# 自动处理 www 前缀，生成 serverNames 列表if [[ $FAKE_DEST_DOMAIN == www.* ]]; then    SERVER_NAMES=&quot;\\&quot;$&#123;FAKE_DEST_DOMAIN&#125;\\&quot;, \\&quot;$(echo $&#123;FAKE_DEST_DOMAIN&#125; | sed &#x27;s/www.//&#x27;)\\&quot;&quot;else    SERVER_NAMES=&quot;\\&quot;$&#123;FAKE_DEST_DOMAIN&#125;\\&quot;&quot;fi# 生成凭证print_color &quot;$YELLOW&quot; &quot;正在生成 UUID 和 REALITY 密钥对...&quot;USER_UUID=$(/usr/local/bin/xray uuid)KEY_PAIR_OUTPUT=$(/usr/local/bin/xray x25519)PRIVATE_KEY=$(echo &quot;$KEY_PAIR_OUTPUT&quot; | grep &quot;Private key&quot; | awk &#x27;&#123;print $3&#125;&#x27;)PUBLIC_KEY=$(echo &quot;$KEY_PAIR_OUTPUT&quot; | grep &quot;Public key&quot; | awk &#x27;&#123;print $3&#125;&#x27;)SHORT_ID=$(head /dev/urandom | tr -dc &#x27;a-f0-9&#x27; | head -c 16)# 创建 config.json 文件CONFIG_JSON_CONTENT=$(cat &lt;&lt;EOF&#123;    &quot;log&quot;: &#123;        &quot;loglevel&quot;: &quot;warning&quot;    &#125;,    &quot;routing&quot;: &#123;        &quot;domainStrategy&quot;: &quot;IPIfNonMatch&quot;,        &quot;rules&quot;: [            &#123; &quot;type&quot;: &quot;field&quot;, &quot;ip&quot;: [&quot;geoip:private&quot;], &quot;outboundTag&quot;: &quot;block&quot; &#125;,            &#123; &quot;type&quot;: &quot;field&quot;, &quot;protocol&quot;: [&quot;bittorrent&quot;], &quot;outboundTag&quot;: &quot;block&quot; &#125;        ]    &#125;,    &quot;inbounds&quot;: [        &#123;            &quot;port&quot;: 443,            &quot;protocol&quot;: &quot;vless&quot;,            &quot;settings&quot;: &#123;                &quot;clients&quot;: [                    &#123;                        &quot;id&quot;: &quot;$&#123;USER_UUID&#125;&quot;,                        &quot;level&quot;: 0,                        &quot;flow&quot;: &quot;xtls-rprx-vision&quot;                    &#125;                ],                &quot;decryption&quot;: &quot;none&quot;            &#125;,            &quot;streamSettings&quot;: &#123;                &quot;network&quot;: &quot;tcp&quot;,                &quot;security&quot;: &quot;reality&quot;,                &quot;realitySettings&quot;: &#123;                    &quot;show&quot;: false,                    &quot;dest&quot;: &quot;$&#123;FAKE_DEST_DOMAIN&#125;:443&quot;,                    &quot;xver&quot;: 0,                    &quot;serverNames&quot;: [$&#123;SERVER_NAMES&#125;],                    &quot;privateKey&quot;: &quot;$&#123;PRIVATE_KEY&#125;&quot;,                    &quot;shortIds&quot;: [&quot;$&#123;SHORT_ID&#125;&quot;]                &#125;            &#125;,            &quot;sniffing&quot;: &#123; &quot;enabled&quot;: true, &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;] &#125;        &#125;    ],    &quot;outbounds&quot;: [        &#123; &quot;protocol&quot;: &quot;freedom&quot;, &quot;tag&quot;: &quot;direct&quot; &#125;,        &#123; &quot;protocol&quot;: &quot;blackhole&quot;, &quot;tag&quot;: &quot;block&quot; &#125;    ]&#125;EOF)echo &quot;$&#123;CONFIG_JSON_CONTENT&#125;&quot; | sudo tee /usr/local/etc/xray/config.json &gt;/dev/null# 测试、重启并设置开机自启print_color &quot;$YELLOW&quot; &quot;正在验证配置并启动 Xray...&quot;if sudo /usr/local/bin/xray run -test -config /usr/local/etc/xray/config.json; then    sudo systemctl restart xray    sudo systemctl enable xray    print_color &quot;$GREEN&quot; &quot;✅ Xray 启动成功！&quot;    sleep 2    sudo systemctl status xray --no-pager -lelse    print_color &quot;$RED&quot; &quot;❌ Xray 配置文件无效！请检查 /usr/local/etc/xray/config.json&quot;    exit 1fi# --- 最终信息汇总 ---echo &quot;&quot;print_color &quot;$GREEN&quot; &quot;=======================================================================&quot;print_color &quot;$GREEN&quot; &quot;            🎉 恭喜！服务器端部署已全部完成！ 🎉&quot;print_color &quot;$GREEN&quot; &quot;=======================================================================&quot;echo &quot;&quot;print_color &quot;$YELLOW&quot; &quot;请妥善保管以下客户端连接参数:&quot;echo &quot;-----------------------------------------------------------------------&quot;echo -e &quot;  服务器地址 (IP):  $(curl -s ip.sb)&quot;echo -e &quot;  端口 (Port):      443&quot;echo -e &quot;  UUID:             $&#123;GREEN&#125;$&#123;USER_UUID&#125;$&#123;NC&#125;&quot;echo -e &quot;  流控 (Flow):      xtls-rprx-vision&quot;echo -e &quot;  加密 (Security):  reality&quot;echo -e &quot;  域名 (ServerName):  $&#123;GREEN&#125;$&#123;FAKE_DEST_DOMAIN&#125;$&#123;NC&#125;&quot;echo -e &quot;  公钥 (PublicKey):   $&#123;GREEN&#125;$&#123;PUBLIC_KEY&#125;$&#123;NC&#125;&quot;echo -e &quot;  短ID (ShortId):     $&#123;GREEN&#125;$&#123;SHORT_ID&#125;$&#123;NC&#125;&quot;echo -e &quot;  指纹 (Fingerprint): chrome&quot;echo &quot;-----------------------------------------------------------------------&quot;echo &quot;&quot;print_color &quot;$YELLOW&quot; &quot;您现在可以使用以上参数配置您的客户端了。&quot;echo &quot;&quot;\n","tags":["Network","VPS"]},{"title":"吐槽一下概率论的定义符号","url":"/2025/01/31/insight/prob_base/","content":"写在前面恕我愚笨，在第一次学概率论的时候一直搞不清楚基础的定义，似乎后来所有的公式都是或多或少靠背诵的；重新回来复习的时候看到了基础的条件概率的定义，实在是觉得反直觉，因此用我自己喜欢的方式重写一下，方便日后速查。\n条件概率就是为了理解什么是条件概率，常见的条件概率的定义是这样的：\nP(B|A) = \\frac{P(A,B)}{P(A)}\\tag{1}意味着，在发生事件A的条件下，事件B发生的概率。\n令人迷惑的是什么是“在发生事件A的条件下”，而且后面会讨论到什么是不发生这件事情的概率，因此所以我喜欢先修改事件的定义为 A_i \\in {A}, i=0,1,...,|A| ，B_j \\in {B}, j=0,1,...,|B|，这样便于观察两个不同的事件组中的所有的事件的交叉可能性，而不再是一个事件发生xx情况的可能性。\n这样定义两个事件的条件概率，是最好理解的(因为存在B的时候A不能单独存在)：\nP(B_j|A_i) = \\frac{P(A_i,B_j)}{P(A_i, B)} \\tag{2}简单解释就是，“在A_i事件发生的条件下，在B事件族中发生B_j事件的可能性”。\n贝叶斯公式贝叶斯公式巧妙地联结了逆序的因果，如果说条件概率：P(B_j|A_i) 是 P(果|因) 的话，那么贝叶斯就是找到了 P(果|因) = Bayes(P(因|果))，也就是说，条件和结果是可互换的。\n常见的写法是：\nP(B|A) = \\frac{P(B)P(A|B)}{P(A)} = \\frac{P(B)P(A|B)}{P(B)P(A|B) + P(¬ {B})P(A|¬ B)} \\tag{3}但是这无论是顺序还是其中的定义符号，都太反化简约掉和对于事件的定义的直觉了，而且让我感觉困惑，因此按照公式(2)，可以改写成：\nP(B_j|A_i) = \\frac{P(A_i,B_j)}{P(A_i, B)} = \\frac{P(A_i|B_j)P(B_j)}{P(A_i|B_j)P(B_j) + P(A_i|B \\backslash B_j)P(B \\backslash B_j)} \\tag{4}这样一切都很顺眼了，分子就是公式(2)得到，分母就是：\nP(A_i, B) = P(A_i, B_j) + P(A_i, B \\backslash B_j)这样的形式其实也更好地能够引出为什么香农(Claude Elwood Shannon)会用log来定义信息熵，因为对数函数就是具有这样的性质：\nlogB + log(B/B_j) = log(B/B_j\\times B_j) = logB例子说服我自己，也说服你，试试看呢说不定就更有道理，哈哈哈哈。\n栗子1\n事件族 \\{A_i\\} ：明天下雨的情况\n\nA_0：不下雨\nA_1：下雨\n\n\n事件族 \\{B_j\\} ：某学生明天去上学的情况\n\nB_0：不上学\nB_1：上学\n\n\n\n我们可以用联合概率 P(A_i, B_j) 来表示两个事件同时发生的概率。根据你提供的表格，我们有：\n\n\n\n\nP(A_i, B_j)\nB_0(不上学)\nB_1(上学)\n\n\n\n\nA_0(不下雨)\n1/3\n1/3\n\n\nA_1(下雨)\n1/12\n1/4\n\n\n\n\n重新表述问题假设我们想要计算在某个特定条件下（例如，给定 A_i ）事件 B_j 发生的概率，即条件概率 P(B_j | A_i)。根据贝叶斯公式，我们可以这样计算：\nP(B_j | A_i) = \\frac{P(A_i, B_j)}{P(A_i,B)}其中：\n\nP(A_i, B_j) 是联合概率，即事件 A_i 和事件 B_j 同时发生的概率，\\sum P(A_i, B_j) =1。\nP(A_i, B) 是事件 A_i 发生的边缘概率。\n\n\n\n\n\nA\nA_0(不下雨)\nA_1(下雨)\n\n\n\n\nP(A_i)\n2/3\n1/3\n\n\n\n\n\nP(B_j, A) 是事件 B_j 发生的边缘概率。\n\n\n\n\n\nB\nB_0(不上学)\nB_1(上学)\n\n\n\n\nP(B_j)\n5/12\n7/12\n\n\n\n\n先有联合概率才有边缘概率分布！！！除非两个事件族独立\n\n示例计算\n计算 P(B_1 | A_1)（即在下雨的情况下学生上学的概率）：\nP(B_1 | A_1) = \\frac{P(A_1, B_1)}{P(A_1, B)}从表格中可以看到：\nP(A_1, B_1) = \\frac{1}{4}P(A_1, B) = P(A_1, B_0) + P(A_1, B_1) = \\frac{1}{12} + \\frac{1}{4} = \\frac{1}{3}因此：\nP(B_1 | A_1) = \\frac{\\frac{1}{4}}{\\frac{1}{3}} = \\frac{3}{4}\n\n\n栗子2癌症检测 —— 检测结果是阳性为事件A，实际患有癌症为事件C， 该医院检测的可靠度为95%（即患有癌症检测为阳性的概率为95%，没有癌症检测结果为阴性的概率为 95%），人群中患有癌症的概率为1%。求若检测结果为阳性，实际患有癌症的概率是多少。\n重新表述问题好的，我们可以通过贝叶斯公式来解决这个问题。假设：\n\n事件族 \\{A_i\\}：检测结果\n\nA_0：阴性\nA_1：阳性\n\n\n事件族 \\{C_j\\}：实际患有癌症情况\n\nC_0：没有患癌\nC_1：确实患癌\n\n\n\n已知条件如下：\n\n检测的可靠度为95%，即 P(A_1|C_1) = 0.95（患有癌症的情况下被检测为阳性）。\n同时，没患有癌症的情况下被检测为阴性的概率也为95%，因此P(A_0|C_0) = 0.95。\n上述二式可以得到误检率是5%：P(A_1∣¬C_1) = P(A_0∣¬C_0) = P(A_1∣C_0) = P(A_0∣C_1) =1−0.95=0.05\n人群中患有癌症的概率为1%，即 P(C_1) = 0.01。\n因此，没有癌症的概率为 P(C_0) = 1 - P(C) = 0.99。\n\n示例计算我们需要计算的是在检测结果为阳性的情况下，实际患有癌症的概率 P(C_1|A_1) ，即倒置因果，贝叶斯。\nP(C_1|A_1) = \\frac{P(C_1, A_1)}{P(C_1,A)} = \\frac{P(A_1 | C_1)P(C_1)}{P(A_1 | C_1)P(C_1) + P(A_1 | C_0)P(C_0)} \\approx 0.161\n或者，我们还有其他的解释词：\n将癌症检测问题转化为机器学习中的混淆矩阵，可以帮助我们更直观地理解模型的预测结果与实际情况之间的关系。混淆矩阵是一个特定格式的表格，用于描述分类模型（或“分类器”）的表现，显示了每个类别被正确和错误分类的情况。\n在你提供的癌症检测问题中，我们可以将其视为一个二分类问题，其中：\n\n正类（Positive, P）：实际患有癌症。\n负类（Negative, N）：实际上没有癌症。\n\n基于这些定义，我们可以构建如下的混淆矩阵（Confusion Matrix）：\n\n\n\n\n\n预测: 患有癌症 (阳性)\n预测: 未患癌症 (阴性)\n\n\n\n\n实际: 患有癌症\n真阳性 (TP)\n假阴性 (FN)\n\n\n实际: 未患癌症\n假阳性 (FP)\n真阴性 (TN)\n\n\n\n\n\n真阳性 (TP)：实际上患有癌症且被正确诊断为阳性的概率是 P(A_1 | C_1)P(C_1) = 0.95 \\times 0.01 = 0.0095 。\n假阴性 (FN)：实际上患有癌症但被错误地诊断为阴性的概率是 1 - TP = 0.05 \\times 0.01 = 0.0005 。\n假阳性 (FP)：实际上未患癌症但被错误地诊断为阳性的概率是 P(A_1 | C_0)P(C_0) = 0.05 \\times 0.99 = 0.0495 。\n真阴性 (TN)：实际上未患癌症且被正确诊断为阴性的概率是 1 - FP = 0.95 \\times 0.99 = 0.9405 。\n\n因此，淆矩阵如下所示：\n\n\n\n\n\n预测: 患有癌症 (阳性)\n预测: 未患癌症 (阴性)\n\n\n\n\n实际: 患有癌症\n0.95%\n0.05%\n\n\n实际: 未患癌症\n4.95%\n94.05%\n\n\n\n\n通过混淆矩阵，我们可以计算各种性能指标来评估分类器的效果，比如准确率（Accuracy）、精确率（Precision）、召回率（Recall），以及F1分数（F1 Score）。这些指标帮助我们全面了解分类模型的表现。\n其实原题就是求精确率\n计算公式1. 准确率（Accuracy）准确率是指所有预测正确的样本占总样本数的比例。\n\\text{Accuracy} = \\frac{TP + TN}{TP + TN + FP + FN}代入具体数值：\n\\text{Accuracy} = \\frac{0.0095 + 0.9405}{0.0095 + 0.9405 + 0.0495 + 0.0005} = \\frac{0.95}{1} = 0.952. 精确率（Precision）精确率是指被预测为正类的样本中实际为正类的比例。\n\\text{Precision} = \\frac{TP}{TP + FP}代入具体数值：\n\\text{Precision} = \\frac{0.0095}{0.0095 + 0.0495} = \\frac{0.0095}{0.059} \\approx 0.1613. 召回率（Recall）召回率是指实际为正类的样本中被正确预测为正类的比例。\n\\text{Recall} = \\frac{TP}{TP + FN}代入具体数值：\n\\text{Recall} = \\frac{0.0095}{0.0095 + 0.0005} = \\frac{0.0095}{0.01} = 0.954. F1 分数（F1 Score）F1分数是精确率和召回率的调和平均值，提供了单一指标来评估模型的整体表现。\n\\text{F1 Score} = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}}代入精确率和召回率的具体数值：\n\\text{F1 Score} = 2 \\cdot \\frac{0.161 \\cdot 0.95}{0.161 + 0.95} \\approx 2 \\cdot \\frac{0.15295}{1.111} \\approx 0.275总结\n准确率 (Accuracy): 0.95 或者 95%\n精确率 (Precision): 0.161 或者 16.1%\n召回率 (Recall): 0.95 或者 95%\nF1 分数 (F1 Score): 0.275 或者 27.5%\n\n这些指标展示了模型在不同方面的表现：\n\n虽然整体准确率很高（95%），但这是因为大多数样本都是负类（未患癌症）。\n精确率较低（16.1%），意味着在所有被诊断为阳性的病例中，只有大约16.1%确实是患有癌症的。\n召回率较高（95%），说明大部分实际患有癌症的人都能被正确诊断出来。\nF1分数综合考虑了精确率和召回率，反映了模型在这两个方面的平衡情况。\n\n"},{"title":"Configure Clash Nyanpasu on Linux","url":"/2025/07/27/fast_startup/Configure-Clash-Nyanpasu-on-Linux/","content":"Choosing and Setting up Clash.Nyanpasu Client on Linux\n\nThis guide will walk you through setting up Clash.Nyanpasu on a Linux server without a graphical user interface. We’ll use the Mihomo core, and you’ll learn how to manage your proxy settings via the command line.\nWe recommend using Clash.Nyanpasu for its robust features and active development.\n1. Determine Your System ArchitectureFirst, identify your Linux server’s architecture to download the correct AppImage. For example, if you have an x86_64 Ubuntu server, you’ll download the amd64.AppImage.\nTo find your architecture, use the command:\nuname -m\nThis will output something like x86_64, aarch64, etc.\n2. Download Clash.NyanpasuNavigate to the Clash.Nyanpasu releases page. Find the latest pre-release or stable release and locate the .AppImage file corresponding to your architecture.\nFor example, for x86_64 (also known as amd64), you might download:\nwget https://github.com/libnyanpasu/clash-nyanpasu/releases/download/pre-release/Clash.Nyanpasu_2.0.0-alpha+2c587d0_amd64.AppImage\nRemember to replace the URL with the specific version you are downloading.\n3. Extract the AppImageAppImages are self-contained executables. While they can often be run directly on systems with FUSE set up, on servers without a graphical environment, you might encounter issues like:\n$ ./Clash.Nyanpasu_2.0.0-alpha+2c587d0_amd64.AppImagefuse: device not found, try &#x27;modprobe fuse&#x27; firstCannot mount AppImage, please check your FUSE setup.You might still be able to extract the contents of this AppImageif you run it with the --appimage-extract option.See https://github.com/AppImage/AppImageKit/wiki/FUSEfor more informationopen dir error: No such file or directory\nAnd sudo modprobe fuse might not work if modprobe is not in your PATH or if you don’t have the necessary kernel modules.\nTo proceed without FUSE, extract the AppImage’s contents:\nchmod +x Clash.Nyanpasu_2.0.0-alpha+2c587d0_amd64.AppImage./Clash.Nyanpasu_2.0.0-alpha+2c587d0_amd64.AppImage --appimage-extract\nThis will create a squashfs-root directory in your current location.\n4. Prepare Configuration Files4.1 Locate the Mihomo ExecutableAfter extraction, the Mihomo core executable (which Clash.Nyanpasu uses) will be located within the squashfs-root directory. Based on the example, it’s typically found at:\n/workspace/squashfs-root/usr/bin/mihomo\n(Note: The path in your system might vary if you extracted it elsewhere. Adjust /workspace/ accordingly.)\n4.2 Create Configuration DirectoryCreate a directory for your Clash configuration files. We’ll use /etc/clash/ as the default in this guide:\nsudo mkdir -p /etc/clash\n4.3 Copy Configuration FilesCopy your config.yaml file (which you should have prepared beforehand, containing your proxy settings) into the /etc/clash/ directory.\nsudo cp /path/to/your/config.yaml /etc/clash/config.yaml\nReplace /path/to/your/config.yaml with the actual path to your configuration file.\n4.4 GeoIP Database (MMDB)Clash uses a GeoIP database (Country.mmdb) for IP-based routing. If you don’t have one, you’ll need to download it. Mihomo typically expects it in the same directory as your config.yaml.\nYou can download Country.mmdb from sources like:\n\nOfficial MaxMind GeoLite2: You need to register for a free account to download GeoLite2-Country.mmdb, then rename it to Country.mmdb.\nThird-party Mirrors (use with caution and verify integrity): Some Clash-related projects provide direct downloads. Search for “Country.mmdb download clash” to find reputable sources.\n\nOnce downloaded, copy it to your configuration directory:\nsudo cp /path/to/your/Country.mmdb /etc/clash/Country.mmdb\n5. Configure Shell EnvironmentTo easily manage Clash and proxy settings, add the following functions to your ~/.bashrc file. This allows you to start Clash, and enable/disable proxy settings with simple commands.\nOpen ~/.bashrc with your preferred editor (e.g., nano or vim):\nnano ~/.bashrc\nAdd the following lines to the end of the file:\n# --- Clash Functions ---clash() &#123;    local MIHOMO_BIN=&quot;/workspace/squashfs-root/usr/bin/mihomo&quot; # Adjust this path if necessary    local DEFAULT_CONFIG_DIR=&quot;/etc/clash/&quot;    local CUSTOM_CONFIG_DIR=&quot;$1&quot; # First argument can be a custom config directory    # Check if mihomo executable exists    if [ ! -f &quot;$MIHOMO_BIN&quot; ]; then        echo &quot;Error: Mihomo executable not found at $MIHOMO_BIN&quot; &gt;&amp;2 # Output to standard error        return 1 # Return non-zero status code for failure    fi    # Determine which config directory to use    local CONFIG_TO_USE=&quot;$DEFAULT_CONFIG_DIR&quot;    if [ -n &quot;$CUSTOM_CONFIG_DIR&quot; ]; then # If a custom config directory is provided        CONFIG_TO_USE=&quot;$CUSTOM_CONFIG_DIR&quot;        echo &quot;Using custom configuration directory: $CONFIG_TO_USE&quot;    else        echo &quot;Using default configuration directory: $DEFAULT_CONFIG_DIR&quot;    fi    # Check if the config directory exists    if [ ! -d &quot;$CONFIG_TO_USE&quot; ]; then        echo &quot;Error: Clash configuration directory not found at $CONFIG_TO_USE&quot; &gt;&amp;2        echo &quot;Please ensure this directory exists and contains a config.yaml file.&quot; &gt;&amp;2        return 1    fi    echo &quot;Starting Mihomo...&quot;    # Using exec ensures mihomo replaces the current shell process, so when mihomo exits, the function also ends.    # If you want mihomo to run in the background, remove &#x27;exec&#x27; and add &#x27;&amp;&#x27; at the end.    &quot;$MIHOMO_BIN&quot; -d &quot;$CONFIG_TO_USE&quot; &quot;$@&quot;    # &quot;$@&quot; passes all arguments of the function to mihomo, allowing you to run: clash /path/to/my/config --port 7890    echo &quot;Mihomo started or exited.&quot;&#125;# --- Proxy Control Functions ---# Define a function to set system proxy to Clashproxy_on() &#123;    # Check if Clash&#x27;s listening port is provided, otherwise use default    local CLASH_PORT=$&#123;1:-7890&#125; # Default port is 7890    echo &quot;Setting HTTP/HTTPS proxy to Clash (Port: $CLASH_PORT)...&quot;    # Set HTTP and HTTPS proxy environment variables    # Ensure you use your actual Clash listening address, usually 127.0.0.1 (localhost)    export http_proxy=&quot;http://127.0.0.1:$CLASH_PORT&quot;    export https_proxy=&quot;http://127.0.0.1:$CLASH_PORT&quot;    # It&#x27;s also often recommended to set all_proxy to cover more applications (e.g., curl)    export all_proxy=&quot;socks5://127.0.0.1:$CLASH_PORT&quot; # Clash also listens on SOCKS5 proxy    # Set addresses that should not use the proxy, typically including localhost and private network addresses    # Traffic to these addresses usually doesn&#x27;t need to be proxied and could cause issues otherwise    export no_proxy=&quot;localhost,127.0.0.1,::1,*.local,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16&quot;    echo &quot;Proxy set successfully!&quot;    echo &quot;   http_proxy: $http_proxy&quot;    echo &quot;   https_proxy: $https_proxy&quot;    echo &quot;   all_proxy: $all_proxy&quot;    echo &quot;   no_proxy: $no_proxy&quot;&#125;# Define a function to turn off the proxyproxy_off() &#123;    echo &quot;Turning off HTTP/HTTPS proxy...&quot;    # Unset proxy environment variables    unset http_proxy    unset https_proxy    unset all_proxy    unset no_proxy    echo &quot;Proxy turned off.&quot;&#125;\nSave the file and exit the editor.\nApply the changes to your current session:\nsource ~/.bashrc\n6. Running Clash with TMUXSince you’re on a server without a GUI, you’ll want to run Clash in a detached session so it continues running even after you close your terminal. tmux is an excellent tool for this.\n\nStart a new tmux session:\ntmux new -s clash\nYou are now inside a new tmux session named clash.\n\nStart Clash:\nInside the tmux session, run the clash function you defined:\nclash\nYou should see output indicating Mihomo is starting.\n\nDetach from the tmux session:\nPress Ctrl+b then d. You will be returned to your main shell, and Clash will continue running in the background within the tmux session.\n\n\n7. Controlling the ProxyFrom any other terminal window on your server (or your main shell after detaching from tmux):\n\nTo enable the proxy:\nproxy_on\nYou can optionally specify a port if your Clash instance is listening on something other than 7890: proxy_on 8888.\n\nTo disable the proxy:\nproxy_off\n\n\n8. Managing the Clash Session\nTo reattach to the Clash tmux session:\ntmux attach -t clash\n\nTo stop Clash:\nIf you are attached to the clash, you can stop Clash by pressing Ctrl+c in the terminal where Clash is running. This will terminate the Mihomo process and close the tmux pane.\n\nTo kill the tmux session (and Clash running within it):\ntmux kill-session -t clash\n\n\nThis comprehensive setup allows you to efficiently manage Clash.Nyanpasu and your proxy settings on a headless Linux server.\n","tags":["Network","VPS"]},{"title":"Hello World","url":"/2025/01/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Starthexo clean &amp;&amp; hexo generate &amp;&amp; hexo server\nor\nhexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy\nCreate a new posthexo new &quot;My New Post&quot;\nMore info: Writing\nRun serverhexo server\nMore info: Server\nGenerate static fileshexo generate\nMore info: Generating\nDeploy to remote siteshexo deploy\nMore info: Deployment\n"},{"title":"解决CUDA10以后的GPU对于Tensorflow-1.x-gpu的依赖失败","url":"/2025/01/21/fast_startup/tf1_15_gpu_docker/","content":"写在前面工业界对于Tensorflow的喜爱是超乎我的意料的，可以说是因为TF1.x的运行前的静态编译使得对于代码和设备的优化能够更加细致，也可以说是大部分在21世纪10年代蓬勃发展的公司——尤其是中国的——都使用的是Nvidia的Volta架构，比如说V100/T4，这也可以说是在第一批贸易战禁令产物。\n其次是当年Meta(from 2021.10.28)还是Facebook，Google的TF有广大的市场，且启蒙我的《Deep Learning with Python》作者François Chollet领衔了Keras的集成进入TF. 以及轰轰烈烈的TF的2.x版本。\n彼时就觉得需要同时兼容pyhton+GPU编译+对应版本的TF库十分麻烦，尤其是对于初学者和便捷的Windows笔记本用户随时拉取一下github的项目测试一下，同时现在Docker越来越受到欢迎因此，姑且本文先通过Docker来省去一切的“为什么我的设备运行不了”的问题来列出解决步骤。\n废话就这么多，七步以内搞定。\n在Windows上使用Docker运行TensorFlow 1.15并启用GPU加速本指南以TF1.15为例，将帮助你在Windows上使用Docker运行TensorFlow 1.15，并充分利用你的NVIDIA GPU进行加速。将从安装Docker和NVIDIA支持开始，逐步引导完成整个过程。\n极简叙述\n安装Docker Desktop for Windows。\n安装NVIDIA GPU驱动程序，确保系统支持CUDA。\n拉取Docker镜像, &gt;&gt; docker pull tensorflow/tensorflow:1.15.0-gpu-py3\n启动Docker，&gt;&gt; docker run --gpus all -it --rm tensorflow/tensorflow:1.15.0-gpu-py3 bash\n确认Docker内CUDA和cuDNN，&gt;&gt; nvcc -V\n检查GPU可用， &gt;&gt; python -c “import tensorflow as tf; devices = tf.config.experimental.list_physical_devices(‘GPU’); print(devices)”\n输出为你的电脑的GPU数目即可。\n!!!该方法并不能够解决编译静态graph时候卡住的问题\n\n\n\n详细展开与特殊情况步骤1：安装Docker和NVIDIA Docker支持\n安装Docker Desktop for Windows\n\n下载并安装 Docker Desktop&lt;—点击进入，选择自己的机器对应的型号（通常Windows带了Nvidia的GPU的笔记本都是AMD64）。\n启动Docker并确保它在后台运行。docker --version\n输出理应格式如下：Docker version 20.10.17, build 100c701\n\n\n\n安装NVIDIA驱动程序和CUDA支持\n\n确保安装了最新版本的 NVIDIA GPU驱动程序&lt;—点击进入，选择自己的机器对应的型号。\\star只是为了能够运行查看当前的机器是不是有GPU！！如果没有请按照正常的tensorflow(默认cpu版本)安装就可以。在Windows本机环境下运行nvidia-smi\n输出理应格式如下：+-----------------------------------------------------------------------------------------+| NVIDIA-SMI 566.14                 Driver Version: 566.14         CUDA Version: 12.7     ||-----------------------------------------+------------------------+----------------------+| GPU  Name                  Driver-Model | Bus-Id          Disp.A | Volatile Uncorr. ECC || Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. ||                                         |                        |               MIG M. ||=========================================+========================+======================||   0  NVIDIA GeForce RTX 4060 ...  WDDM  |   00000000:01:00.0  On |                  N/A || N/A   49C    P4              8W /  109W |    2301MiB /   8188MiB |      2%      Default ||                                         |                        |                  N/A |+-----------------------------------------+------------------------+----------------------++-----------------------------------------------------------------------------------------+| Processes:                                                                              ||  GPU   GI   CI        PID   Type   Process name                              GPU Memory ||        ID   ID                                                               Usage      ||=========================================================================================||    0   N/A  N/A      ...    C+G   D:\\Microsoft VS Code\\Code.exe                N/A      ||    ...   N/A  N/A      ...    ...   ...      ...                                         |+-----------------------------------------------------------------------------------------+\n\n\n\n\n步骤2：拉取Docker镜像\n打开命令行工具并运行以下命令来获得docker镜像：\n docker pull tensorflow/tensorflow:1.15.0-gpu-py3\n 注意：其中的格式为docker pull tensorflow/tensorflow:1.xx-suffix_1-suffix_2 其中，tensorflow:1.xx-suffix_1，表示需要的版本，suffix_1一般添加gpu（不然你来看这干啥呢是吧） 其次，-suffix_2可以省略，由于其默认的下载是由Python2中的tensorflow包，是由Python2（e.g. 2.7.15+）版本编译的对于需要额外的Python3的语法项目存在部分冲突，所以建议添加此项为-py3。\n\n等待下载完成后，运行Docker的镜像：\n docker run --gpus all -it --rm tensorflow/tensorflow:1.15.0-gpu-py3 bash\n\n\n步骤3：拉取TensorFlow镜像拉取适用于Python 3环境的TensorFlow 1.15 GPU镜像：\ndocker pull tensorflow/tensorflow:1.15.0-gpu-py3\n输出大致为：________                               __________________  __/__________________________________  ____/__  /________      ____  /  _  _ \\_  __ \\_  ___/  __ \\_  ___/_  /_   __  /_  __ \\_ | /| / /_  /   /  __/  / / /(__  )/ /_/ /  /   _  __/   _  / / /_/ /_ |/ |/ //_/    \\___//_/ /_//____/ \\____//_/    /_/      /_/  \\____/____/|__/WARNING: You are running this container as root, which can cause new files inmounted volumes to be created as the root user on your host machine.To avoid this, run the container by specifying your user&#x27;s userid:$ docker run -u $(id -u):$(id -g) args...root@container_id:/# **后续的所有的代码运行位置，输入Ctrl^D推出docker镜像这时候已经在镜像内了，一切格式都与Linux保持一致运行python -c &quot;import tensorflow as tf; devices = tf.config.experimental.list_physical_devices(&#x27;GPU&#x27;); print(devices)&quot;理应输出最后行格式如下：...blablabla2025-01-21 13:57:35.258965: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1746] Adding visible gpu devices: 0[PhysicalDevice(name=&#x27;/physical_device:GPU:0&#x27;, device_type=&#x27;GPU&#x27;)]gpu编号和列表编号一致从0开始，即说明成功啦！\n","tags":["ENV"]},{"title":"Brief Reinforcement Learning 01 - Proximal Policy Optimization (PPO) 简单理解近端策略优化","url":"/2025/07/30/insight/RL/PPO/","content":"写在前面PPO 原文: https://arxiv.org/abs/1707.06347TRPO 原文: https://arxiv.org/abs/1502.05477\n目录\n强化学习基础概念\n策略 (Policy)\n动作 (Action)\n奖励 (Reward)\n轨迹 (Trajectory)\n价值函数 (Value Function) 与 Critic\n演员 (Actor)\n优势函数 (Advantage Function)\n\n\n从 Q-Learning 到 Policy Gradient\nPPO 是什么？\nPPO 流程示意图\nPPO 的核心思想\nPPO 的目标函数 (Objective Function)\n\n\nPPO 算法详解\nClipped Surrogate Objective Function\n多轮次更新 (Multiple Epochs of Minibatch Updates)\nPPO 算法流程\n\n\n实例：用 PPO 玩转石头剪刀布\n环境设定\n模型设计\n训练过程\n结果\n\n\n附录：数学推导\n策略梯度定理推导\n信赖域方法推导\n\n\n\n\n强化学习基础概念在深入 PPO 之前，我们首先需要理解一些强化学习（Reinforcement Learning, RL）的基本构建块。想象一个智能体（Agent）在一个环境（Environment）中学习，它通过不断地试错来最大化自己获得的奖励。\n\n策略 (Policy): \\pi策略是智能体的大脑，它定义了智能体在特定状态下 (s) 会采取什么动作 (a)。策略可以有两种形式：\n\n确定性策略 (Deterministic Policy): a = μ(s)，在每个状态下，动作是确定的。\n随机性策略 (Stochastic Policy): π(a|s) = P(A_t = a | S_t = s)，在每个状态下，策略会给出一个采取各个动作的概率分布。PPO 处理的是随机性策略。\n\n\n动作 (Action): a智能体根据其策略在环境中执行的操作。例如，在游戏中是按下某个按钮，在机器人控制中是移动某个关节。\n\n奖励 (Reward): r当智能体执行一个动作后，环境会反馈一个标量信号——奖励。这个信号评价了这个动作的好坏。智能体的最终目标是最大化累积奖励（Cumulative Reward）。\n\n轨迹 (Trajectory): \\tau智能体与环境交互产生的一系列状态、动作和奖励的序列，可以表示为 \\tau = (s_0, a_0, r_0, s_1, a_1, r_1, ...)。\n\n价值函数 (Value Function) 与 Critic价值函数用来评估一个状态或一个状态-动作对的“好坏”程度，即从该点出发，预期未来能获得多少总奖励。\n\n状态价值函数 (State-Value Function) V^\\pi(s): 从状态 s 出发，遵循策略 \\pi，所能获得的期望总回报。\n动作价值函数 (Action-Value Function) Q^\\pi(s, a): 在状态 s 下，执行动作 a，然后遵循策略 \\pi，所能获得的期望总回报。在 Actor-Critic 架构中，Critic（评论家） 的角色就是学习并输出价值函数，它的作用是“评价”当前 Actor 的表现好坏，但它自己不决定做什么动作。\n\n\n演员 (Actor)Actor（演员） 的角色是学习并执行策略 \\pi。它根据当前状态 s，决定要采取哪个动作 a。Actor 的目标是调整策略，以获得更高的总回报。\n\n优势函数 (Advantage Function): A^\\pi(s, a)优势函数是衡量在状态 s 下，采取动作 a 相对于遵循当前策略 \\pi 的平均表现有多好。它的计算公式是：\nA^\\pi(s, a) = Q^\\pi(s, a) - V^\\pi(s)\n如果 A > 0, 说明动作 a 比平均水平要好。\n如果 A < 0, 说明动作 a 比平均水平要差。\n\n 优势函数是 PPO 算法中的一个核心概念，它告诉我们策略更新应该朝哪个方向进行。\n\n\n从 Q-Learning 到 Policy Gradient传统的 Q-Learning 是一种基于价值的方法。它通过学习一个最优的动作价值函数 Q^*(s, a) 来间接得到最优策略。其策略通常是贪婪的：在状态 s 下，选择使 Q(s, a) 值最大的动作 a。这种方法在处理连续动作空间或需要随机策略时会遇到困难。\n为了解决这些问题，策略梯度 (Policy Gradient, PG) 方法应运而生。PG 不再学习价值函数，而是直接对策略 \\pi_\\theta(a|s) 进行参数化（\\theta 是神经网络的参数），然后通过梯度上升来优化策略，以最大化期望总回报 J(\\theta)。\nPG 的核心思想很简单：如果一个动作带来了好的结果（即高的优势值），我们就增加这个动作被选择的概率；反之，则减少。\n然而，朴素的 PG 算法存在一些问题：\n\n高方差：梯度的估计可能非常不稳定，导致训练过程震荡。\n更新步长难以确定：如果更新步长（学习率）太大，可能会导致策略“崩溃”，即更新后的策略表现急剧下降，且难以恢复。如果步长太小，则训练速度过慢。\n\nPPO 是什么？近端策略优化 (Proximal Policy Optimization, PPO) 是一种旨在解决策略梯度方法中更新步长问题的算法。它是对 信赖域策略优化 (Trust Region Policy Optimization, TRPO) 的一种简化，在实现上更简单，但效果同样出色。\nPPO 流程示意图下面是一个简化的 PPO 工作流程图：\ngraph TD    A[Actor: π_θ_old] -- &quot;与环境交互&quot; --&gt; B(收集轨迹 τ);    B -- &quot;计算每个时间步的优势 A_t&quot; --&gt; C;    C[Critic: V_φ] -- &quot;计算V(s_t)辅助计算A_t&quot; --&gt; B;    B -- &quot;将(s_t, a_t, A_t)存入缓冲区&quot; --&gt; D(经验缓冲区);    D -- &quot;重复K个Epoch&quot; --&gt; E&#123;优化循环&#125;;    E -- &quot;采样一个Minibatch&quot; --&gt; F(计算PPO目标函数 L_CLIP);    F -- &quot;计算梯度 ∇_θ L_CLIP&quot; --&gt; G(更新Actor网络参数 θ);    E -- &quot;采样一个Minibatch&quot; --&gt; H(计算价值损失 L_VF);    H -- &quot;计算梯度 ∇_φ L_VF&quot; --&gt; I(更新Critic网络参数 φ);    G &amp; I -- &quot;K个Epoch结束后&quot; --&gt; J[新策略 π_θ];    J -- &quot;π_θ_old ← π_θ&quot; --&gt; A;\nPPO 的核心思想PPO 的核心思想是：在尝试最大化目标函数的同时，使用一个“惩罚”项来限制新旧策略之间的差异，确保每次更新不会让策略变得太离谱。\n想象一下你在一个山坡上试图走到山顶（最大化奖励）。朴素的 PG 方法就像是你蒙着眼睛朝你认为最陡峭的方向迈出一大步，但你可能会不小心滚下悬崖（策略崩溃）。PPO 则是在你脚上绑了一根绳子，绳子的另一端固定在你之前的位置。你可以自由地向任何方向迈步，但如果步子迈得太大，绳子就会把你拉回来，防止你摔得太远。\n这个“绳子”就是 PPO 中的 Clipping (裁剪) 机制。\nPPO 的目标函数 (Objective Function)PPO 的目标函数是其精髓所在，我们先来看最常用的 PPO-Clip 的目标函数：\nL^{CLIP}(\\theta) = \\hat{\\mathbb{E}}_t \\left[ \\min\\left( r_t(\\theta) \\hat{A}_t, \\text{clip}(r_t(\\theta), 1 - \\epsilon, 1 + \\epsilon) \\hat{A}_t \\right) \\right]r_t(\\theta) = \\frac{\\pi_\\theta(a_t | s_t)}{\\pi_{\\theta_{\\text{old}}}(a_t | s_t)}让我们来拆解这个复杂的公式：\n\n\\hat{\\mathbb{E}}_t[...]: 表示对一个批次（batch）中所有时间步 t 的样本取平均。\nr_t(\\theta): 这是新旧策略之间的概率比率 (probability ratio)。\n\\pi_\\theta(a_t | s_t): 当前正在优化的新策略。\n\\pi_{\\theta_{\\text{old}}}(a_t | s_t): 用于收集数据的旧策略。\n如果 r_t(\\theta) > 1, 说明新策略更倾向于采取动作 a_t。\n如果 r_t(\\theta) < 1, 说明新策略不太倾向于采取动作 a_t。\n\n\n\\hat{A}_t: 这是在时间步 t 的优势函数 Advantage 的估计值。\n\\text{clip}(r_t(\\theta), 1 - \\epsilon, 1 + \\epsilon) : 这个函数将概率比率 r_t(\\theta) 裁剪到一个范围 [1 - \\epsilon, 1 + \\epsilon] 内。\\epsilon 是一个超参数，通常取 0.1 或 0.2。\n\\min(...): PPO 的关键部分。它在两个项之间取最小值。\n\nPPO 算法详解Clipped Surrogate Objective Function我们来详细分析 \\min 函数中的两项：\n\nr_t(\\theta) \\hat{A}_t: 这是标准的策略梯度目标函数。如果优势 \\hat{A}_t 是正的，我们会想要增大 r_t(\\theta)（即增加 \\pi_\\theta(a_t|s_t)），从而最大化这一项。如果 \\hat{A}_t 是负的，我们会想要减小 r_t(\\theta)。\n\n\\text{clip}(r_t(\\theta), 1 - \\epsilon, 1 + \\epsilon) \\hat{A}_t: 这是被裁剪过的版本，是 PPO 的创新之处。\n\n\n为什么要取 \\min？\n这是一种悲观主义的或者说保守的更新方式。\n\n当 \\hat{A}_t > 0 (好动作) 时:\nL^{CLIP} = \\hat{\\mathbb{E}}_t \\left[ \\min(r_t(\\theta), 1 + \\epsilon) \\hat{A}_t \\right]这意味着，我们希望增加好动作的概率 (r_t(\\theta) 变大)，但是这个增加是有限度的。r_t(\\theta) 最多只能增长到 1+\\epsilon。这防止了策略因为一个特别好的动作而过度更新，导致在其他状态下表现变差。\n\n当 \\hat{A}_t < 0 (坏动作) 时:\nL^{CLIP} = \\hat{\\mathbb{E}}_t \\left[ \\max(r_t(\\theta), 1 - \\epsilon) \\hat{A}_t \\right](注意，因为 \\hat{A}_t 是负数，\\min 实际上变成了 \\max）。这意味着，我们希望减小坏动作的概率 (r_t(\\theta) 变小)，但这个减小也是有限度的。r_t(\\theta) 最少只能减小到 1-\\epsilon。这防止了策略因为一个坏动作而过度惩罚，导致策略完全放弃探索某些可能在未来有价值的动作。\n\n\n通过这种方式，PPO 将策略更新限制在了一个“信赖域”内，使得训练过程更加稳定。\n多轮次更新 (Multiple Epochs of Minibatch Updates)PPO 的另一个重要特点是它可以在同一批数据上进行多次（K个Epoch）的梯度更新。这大大提高了样本的利用效率。传统的 A2C (Advantage Actor-Critic) 算法每收集一批数据只能更新一次网络，而 PPO 可以用这批数据训练好几个 Epoch，只要策略更新不偏离旧策略太远（由 Clip 机制保证）。\nPPO 算法流程下面是 PPO 算法更具体的伪代码：\n\n初始化: 初始化 Actor 网络 \\pi_\\theta 和 Critic 网络 V_\\phi 的参数 \\theta, \\phi。\n循环 (for iteration = 1, 2, …):a.  数据收集: 使用当前策略 \\pi_{\\theta_{\\text{old}}} \\leftarrow \\pi_\\theta，与环境交互 N 个时间步，收集一批轨迹 \\mathcal{D} = \\{\\tau_i\\}。b.  优势计算: 对收集到的每个时间步 t，计算优势函数 \\hat{A}_t。通常使用 GAE (Generalized Advantage Estimation) 方法来平衡偏差和方差。\n\\hat{A}_t = \\delta_t + (\\gamma\\lambda)\\delta_{t+1} + ... + (\\gamma\\lambda)^{T-t+1}\\delta_{T-1}其中 \\delta_t = r_t + \\gamma V(s_{t+1}) - V(s_t)c.  优化循环 (for epoch = 1, 2, …, K):\n\n从 \\mathcal{D} 中随机采样一个小批量（Minibatch）数据。\n计算 Actor 的损失 L^{CLIP}(\\theta)。\n计算 Critic 的损失 L^{VF}(\\phi) = ||(V_\\phi(s_t) - V_t^{\\text{target}}||^2_2 (均方误差)。V_t^{\\text{target}} 通常是 \\hat{A}_t + V_\\phi(s_t)。\n（可选）计算熵损失 S[\\pi_\\theta](s_t)，鼓励探索。\n更新 Actor 和 Critic 的网络参数：\n\n\\theta \\leftarrow \\theta - \\alpha_\\theta \\nabla_\\theta (L^{CLIP} - c_1 L^{VF} + c_2 S)\\phi \\leftarrow \\phi - \\alpha_\\phi \\nabla_\\phi L^{VF}\n结束\n\n实例：用 PPO 玩石头剪刀布让我们看一个简单的例子：训练一个 AI 来玩石头剪刀布。\n环境设定\n对手: 不是完全随机的，而是一个有特定偏好的对手。比如，他出“石头”的概率是 50%，出“剪刀”和“布”的概率各是 25%。\n状态 (State): 为了简单起见，我们可以将状态设为对手上一次出的手势。如果游戏是独立的，状态也可以是一个常数。\n动作 (Action): 我们的 AI 可以选择出“石头”(0)、“剪刀”(1) 或“布”(2)。\n奖励 (Reward):\n赢: +1\n平: 0\n输: -1\n\n\n\n模型设计\nActor: 一个简单的神经网络。输入是状态（对手上一次的手势，独热编码），输出是三个动作（石头、剪刀、布）的概率分布（通过 Softmax 层）。\nCritic: 另一个简单的神经网络。输入是状态，输出是一个标量，代表当前状态的价值 V(s)。\n\n训练过程\n初始化: 随机初始化 Actor 和 Critic 网络的权重。我们的 AI 一开始是胡乱出拳的。\n收集数据: 让我们的 AI (Actor) 和有偏好的对手玩，比如玩 100 局。记录下每一局的状态、我们出的动作、以及获得的回报。例如，记录 (s_t= 对手出石头 , a_t= 我出剪刀, r_t= -1)。\n计算优势:\n用 Critic 网络预测每一局开始时的状态价值 V(s_t)。\n因为石头剪刀布是单步游戏，优势函数可以简化为 A_t = r_t - V(s_t)。\n例如，在 s_t（对手上把出石头）时，我们出了“布”赢了 (r_t=1)。假设 Critic 预测 V(s_t)=0.1。那么优势 A_t = 1 - 0.1 = 0.9。这是一个很大的正优势。\n\n\nPPO 更新:\n我们使用收集到的 100 局数据，进行多轮（比如 K=4）优化。\n在每一轮中，我们计算 PPO 的 L_CLIP 损失。\n对于刚才那个例子，因为 A_t=0.9 是正的，算法会尝试提高在 s_t 状态下出“布”的概率。\nclip 机制会确保这个概率的提升不会太大，比如 r_t 不会超过 1.2。\n同时，我们也更新 Critic 网络，让它的预测 V(s_t) 更接近实际获得的回报 r_t。\n\n\n重复: 不断地重复步骤 2-4。\n\n结果经过多轮训练后：\n\nActor 会学到，当对手有 50% 的概率出“石头”时，我应该提高出“布”的概率，这样胜率最高。它的策略会逐渐收敛到一个最优解（高概率出布）。\nCritic 会学到，在面对这个对手时，游戏的初始状态价值是正的，因为我们有优势。\n\n这个例子展示了 PPO 如何通过与环境交互，稳定地学习到一个能利用环境特性（对手偏好）的策略。\n\n附录：数学推导这里提供了一些核心概念的数学推导，以供深入理解。\n[策略梯度定理推导]策略梯度定理是策略梯度方法的基础，它表明了目标函数 J(\\theta) 的梯度可以被写成一个期望的形式，从而可以用蒙特卡洛采样来估计。我们的目标是找到能最大化期望总回报 J(\\theta) 的策略参数 \\theta。\n1. 目标函数定义\n首先，我们定义目标函数 J(\\theta) 为遵循策略 \\pi_\\theta 时，所有可能轨迹 \\tau 的期望总回报。\nJ(\\theta) = \\mathbb{E}_{\\tau \\sim \\pi_\\theta} [R(\\tau)] = \\sum_{\\tau} P(\\tau|\\theta) R(\\tau)其中，R(\\tau) = \\sum_{t=0}^{T} r(s_t, a_t) 是轨迹 \\tau 的总回报，P(\\tau|\\theta) 是在参数为 \\theta 的策略下，轨迹 \\tau 发生的概率。\n2. 求目标函数的梯度\n我们对目标函数求关于 \\theta 的梯度：\n\\nabla_\\theta J(\\theta) = \\nabla_\\theta \\sum_{\\tau} P(\\tau|\\theta) R(\\tau) = \\sum_{\\tau} \\nabla_\\theta P(\\tau|\\theta) R(\\tau)3. 应用对数导数技巧 (Log-Derivative Trick)\n直接计算 \\nabla_\\theta P(\\tau|\\theta) 很困难。这里我们使用一个关键技巧：\\nabla_x f(x) = f(x) \\nabla_x \\log f(x)。将其应用到 P(\\tau|\\theta) 上：\n\\nabla_\\theta P(\\tau|\\theta) = P(\\tau|\\theta) \\nabla_\\theta \\log P(\\tau|\\theta)将这个技巧代入梯度公式中：\n\\nabla_\\theta J(\\theta) = \\sum_{\\tau} P(\\tau|\\theta) \\nabla_\\theta \\log P(\\tau|\\theta) R(\\tau)这个形式正好是某个期望值的定义，所以可以写成：\n\\nabla_\\theta J(\\theta) = \\mathbb{E}_{\\tau \\sim \\pi_\\theta} [\\nabla_\\theta \\log P(\\tau|\\theta) R(\\tau)]4. 展开轨迹概率\n现在我们来处理 \\log P(\\tau|\\theta)。一条轨迹的概率是初始状态概率和一系列动作概率与状态转移概率的乘积：\nP(\\tau|\\theta) = p(s_0) \\prod_{t=0}^{T} \\pi_\\theta(a_t|s_t) p(s_{t+1}|s_t, a_t)对其取对数：\n\\log P(\\tau|\\theta) = \\log p(s_0) + \\sum_{t=0}^{T} \\left( \\log \\pi_\\theta(a_t|s_t) + \\log p(s_{t+1}|s_t, a_t) \\right)再对其求关于 \\theta 的梯度。注意到，环境的状态转移概率 p(s_{t+1}|s_t, a_t) 和初始状态概率 p(s_0) 都与策略参数 \\theta 无关，所以它们的梯度为零。因此：\n\\nabla_\\theta \\log P(\\tau|\\theta) = \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t)5. 得到策略梯度的基本形式\n将上式代入第3步的期望公式中，我们得到：\n\\nabla_\\theta J(\\theta) = \\mathbb{E}_{\\tau \\sim \\pi_\\theta} \\left[ \\left( \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) \\right) \\left( \\sum_{t=0}^{T} r(s_t, a_t) \\right) \\right]这个公式虽然正确，但方差很大，因为括号里的回报项 R(\\tau) 会同时乘以过去和未来的所有动作的梯度。\n6. 利用因果关系并引入基线以减小方差\n一个重要的观察是：在时间步 t 的决策 \\pi_\\theta(a_t|s_t) 只会影响从 t 时刻开始的未来回报，而不会影响过去已经获得的回报。因此，我们可以将回报项替换为从当前时刻开始的未来回报总和 G_t = \\sum_{t'=t}^{T} r(s_{t'}, a_{t'})：\n\\nabla_\\theta J(\\theta) = \\mathbb{E}_{\\tau \\sim \\pi_\\theta} \\left[ \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) G_t \\right]为了进一步减小方差，我们可以从回报中减去一个不依赖于动作 a_t 的基线（baseline）b(s_t)。最常用的基线是状态价值函数 V(s_t)。减去基线不会改变梯度的期望值（因为 \\mathbb{E}[\\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) b(s_t)] = 0），但可以显著减小梯度的方差。\n\\nabla_\\theta J(\\theta) = \\mathbb{E}_{\\tau \\sim \\pi_\\theta} \\left[ \\sum_{t=0}^{T} \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) (G_t - V(s_t)) \\right]7. 最终形式：优势函数\n我们发现，G_t - V(s_t) 正是优势函数 A(s_t, a_t) 的一个估计。因此，策略梯度定理最终可以写成我们熟悉的形式：\n\\nabla_\\theta J(\\theta) \\approx \\hat{\\mathbb{E}}_t \\left[ \\nabla_\\theta \\log \\pi_\\theta(a_t|s_t) \\hat{A}_t \\right]这个形式直观地告诉我们：如果一个动作的优势 \\hat{A}_t 是正的，我们就调整参数 \\theta 来增加这个动作的对数概率 \\log \\pi_\\theta(a_t|s_t)；反之亦然。这就是策略梯度方法的核心。\n[信赖域方法推导]TRPO (PPO 的前身) 的目标函数可以写成：\n\\max_\\theta \\quad \\mathbb{E}_{\\substack{s \\sim \\rho^{\\pi_{\\theta_{old}}}， a \\sim \\pi_{\\theta_{old}}}} \\left[ \\frac{\\pi_\\theta(a|s)}{\\pi_{\\theta_{old}}(a|s)} A^{\\pi_{\\theta_{old}}}(s,a) \\right]\\text{s.t.} \\quad \\mathbb{E}_{s \\sim \\rho^{\\pi_{\\theta_{old}}}} \\left[ D_{KL}(\\pi_{\\theta_{old}}(\\cdot|s) || \\pi_\\theta(\\cdot|s)) \\right] \\leq \\delta这里的 D_{KL} 是 KL 散度，用来衡量新旧策略的差异。这个约束确保了策略更新不会偏离旧策略太远，从而保证了训练的稳定性。然而，求解这个带约束的优化问题非常复杂，需要计算二阶导数（Hessian矩阵）。\nPPO 通过 clip 函数来近似这个带约束的优化问题，将其转化为一个无约束的、更容易求解的优化问题。PPO 的目标函数可以看作是 TRPO 目标函数的一阶近似的、加了惩罚项的版本，从而大大简化了计算，同时保留了信赖域方法的稳定性。\n","tags":["Reinforcement Learning"]},{"title":"uv install Quickstart","url":"/2025/07/03/fast_startup/uv-install-quickstart/","content":"\n\nInstalling [uv] and Managing Your Python Projectsuv is a seriously fast and efficient tool for Python package management, written in Rust. It’s a great alternative to pip and virtualenv, speeding up your workflow significantly. Let’s get you set up and show you how to use it.\n\nInstalling [uv]: Three WaysYou’ve got a few simple options for getting uv onto your system:\n\nRecommended (with pipx): This is the best way as it installs uv in its own isolated environment, preventing conflicts with other packages.pip install pipx # If you don&#x27;t have pipx alreadypipx ensurepath    # Make sure pipx&#x27;s executables are on your PATHpipx install uv\nDirectly with pip: A straightforward way if you prefer not to use pipx.pip install uv\nUsing brew (macOS/Linux): If you’re on macOS or Linux and use Homebrew, it’s just one command.brew install uv\n\n\n\nSetting Up and Activating a Virtual Environmentuv makes managing virtual environments a breeze, keeping your project dependencies neatly separated.\nCreating the EnvironmentTo create a new virtual environment in your current directory (it’ll be named .venv by default):\nuv venv\nor you can assign specific version of Python\nuv venv -p 3.10\nActivating the EnvironmentBefore you do anything else in your project, you need to activate this environment:\n\nmacOS/Linux:source .venv/bin/activate\nWindows (Command Prompt):.venv\\Scripts\\activate.bat\nWindows (PowerShell):.venv\\Scripts\\Activate.ps1\n\n\nYou’ll know it’s active because your terminal prompt will usually show (.venv) at the beginning.\nExit can use following:deactivate\nDelete the .venv directory:rm -rf .venv\n\nInstalling Packages with [uv pip install]Once your virtual environment is active, installing packages is very similar to pip, but with uv pip:\n\nInstalling from requirements.txt:uv pip install -r requirements.txt\nInstalling individual packages:uv pip install requests beautifulsoup4\n\n\nImportant Note on Quoting with [uv pip]When installing packages that include extras (optional features) or direct URLs, you must use double quotes to ensure the shell passes the entire string correctly to uv. This is a common point of confusion for pip users moving to uv.\n\nWith extras:uv pip install &quot;celery[redis]&quot;\nFrom a Git repository:uv pip install &quot;git+https://github.com/example/my-lib.git#egg=my-lib&quot;\nLocal editable installs:uv pip install &quot;-e .&quot;\n\n\n\nRunning Your Project with [uv]’s PythonAfter your environment is active and dependencies are installed, you simply use the python command, which now refers to the Python interpreter within your activated .venv.\nIf you have a script named app.py:\npython app.py\nKey point: You don’t use uv python (that command doesn’t exist). Once the environment is activated, your shell automatically uses the python from your .venv.\n\nWhat Makes [uv] Special?uv isn’t just another package manager; it brings some powerful features to the table:\n\nBlazing Speed: This is uv‘s headline feature. Written in Rust, it’s significantly faster than pip for dependency resolution and installation, especially in large, complex projects.\n\nRobust Dependency Resolution: uv is designed to handle complex dependency graphs and potential conflicts much more effectively than pip, leading to more reliable builds.\n\nNo Global Lock (for venvs): Unlike some other tools, uv doesn’t enforce a global lock file across all your virtual environments. Each uv venv operates independently, which simplifies development when you’re juggling multiple projects with different dependency versions. You can manage project-specific lock files (e.g., uv lock) if desired, but it’s not imposed globally.\n\nIntegrated Installer and Resolver: uv combines the roles of pip (installer) and pip-tools or Poetry (resolver) into a single, cohesive tool.\n\n\n\n[uv] beats naive [pip] &amp; [conda] =w=/","tags":["ENV"]},{"title":"GNN系列1-GCN(Graph Convolutional Networks)","url":"/2025/01/23/insight/Graphs/Backbones/GCN/","content":"写在前面作为博客开篇，Graph系列的第一章，一切都只是我浅薄的观察和对于阅读的部分论文得出的见解，不能说是insight，只能够尽可能从我自己的武断认为其可能存在的道理来进行剖析，以及，我特别喜欢的，从发展中向后推进、以预判其潜在的改进空间。\n由于是第一章节，所以会牵扯到很多最最基础的定义，烦请耐心阅读。\n另外，就我对于工业界的实习来看，至少在2025年，当下的图结构数据的开发依然存在极其大的空间。在实际应用中发挥图结构的优势，最最重要的是建模，因为图不再是简单的离散点阵，更有图的结构——这也牵扯到什么是图什么是异构图。即，并非再是像朴素数据挖掘那样探讨如何处理图结构的数据来适应一个自回归任务，而是在于应当如何去构建图结构的数据，去定义什么是边，什么是节点，甚至隐式地定义图。一个非常简单的例子，如何教会机器人通过有限旋转关节的机械臂，来叠衣服，如果说这个方法可以通过将空间和衣服本身建模用点来进行建模的话。也许很多人会有和我一样的疑惑：是否图结构的数据在很多的算法中其实都有所崭露，而只是被其他角度的解读所掩盖了。\nGNN作为一个受到MLP和CV中的卷积神经网络的启发，而从深度学习的角度来建模图结构数据的将其作为一个从图数据到目标域的映射，这般的类推是十分朴实的，但是不可避免的需要“具体问题具体分析”——不是一个通用的网络就能够在所有的图相关任务中都达到最好的效果，就像是大语言模型需要在目标域进行微调一样。\n好，那么下面开始。\n参考原文：(GCN-3 KipfNet)Semi-Supervised Classification with Graph Convolutional Networks ICLR2017 | Paper | Cite代码: torch_geometric.nn.models.GCN\nI. 图结构数据定义常见的定义有二\n\n定义一：基于几何结构数学表示\n\n\\mathcal{G} = (\\mathcal{V},\\mathcal{E})一个图 (\\mathcal{G}) 由以下组成： \n\n节点集合 (\\mathcal{V}): 表示图中的所有节点，通常用 (|\\mathcal{V}| = N) 表示节点的数量。\n边集合 (\\mathcal{E}): 表示节点之间的连接关系，每条边由一对节点 ((u, v) \\in \\mathcal{V} \\times \\mathcal{V}) 表示。 \n节点特征矩阵 (\\mathrm{X}):\\mathrm{X} \\in \\mathbb{R}^{N \\times F}，其中F表示每个节点的特征维度。 \n几何结构(可选): 边的几何信息，如在二维或三维空间中的边的长度、方向等。\n\n形式化表示： \n\n \\mathcal{G} = (\\mathcal{V}, \\mathcal{E}, \\mathrm{X}, \\text{几何信息})示例： \n\n\\mathcal{V} = \\{v_1, v_2, v_3\\}；\n\\mathcal{E} = \\{(v_1, v_2), (v_2, v_3)\\}；\n\\mathrm{X}=\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 1 \\end{bmatrix}；\n边的几何长度：d_{12} = 1.5, d_{23} = 2.0。\n\n\n定义二：基于邻接矩阵数学表示：\n\n\\mathcal{G} = (\\mathrm{A}, \\mathrm{X}, \\mathrm{E})一个图\\mathcal{G}可以用以下方式定义：\n\n邻接矩阵 \\mathrm{A}: 表示图的拓扑结构，是一个\\mathrm{A} \\in \\mathbb{R}^{N \\times N}的稀疏矩阵（一般来说），其中：\n\\mathrm{A}_{ij} = 1表示节点i和j之间存在边；\n\\mathrm{A}_{ij} = 0表示节点i和j之间不存在边。\n\n\n节点特征矩阵 \\mathrm{X}: 表示每个节点的特征，是一个\\mathrm{X} \\in \\mathbb{R}^{N \\times F}，其中F表示每个节点的特征维度。\n边特征矩阵 \\mathrm{E}（可选）: 表示边的特征，是一个\\mathrm{E} \\in \\mathbb{R}^{|\\mathcal{E}| \\times F_e}，其中F_e表示每条边的特征维度。\n\n形式化表示：\n\n\\mathcal{G} = (\\mathrm{A}, \\mathrm{X}, \\mathrm{E})示例\n\\mathrm{A} = \\begin{bmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\\\ 0 & 1 & 0 \\end{bmatrix}；\n\n\\mathrm{X} = \\begin{bmatrix} 1 & 2 \\\\ 0 & 3 \\\\ 1 & 0 \\end{bmatrix}；\n\n\\mathrm{E} = \\begin{bmatrix} 0.5 \\\\ 0.8 \\\\ 1.2 \\end{bmatrix}（如边的权重或距离信息 ）。\n\n\n\n定义一关注几何结构，常用于需要明确空间信息的问题，如三维物体重建、分子建模和机器人路径规划，解决几何形状分析、分子性能预测和空间导航等问题；定义二更加关注节点信息和节点间的信息关系，广泛应用于社交网络、推荐系统和知识图谱，主要解决关系建模、个性化推荐以及复杂网络中信息传播与预测的问题。\n当然了在现在的很多工业应用当中抛弃显式的图结构，用简单的神经网络和序列建模Transformer类似的交叉注意力结构也依然能够得到一个非常好的效果，因为大部分工业应用中更加重视速度——尽管这个速度可以是通过学术界新创新方法之后不断地优化得到的。\nII. GCN原理图卷积网络可以分解为层的堆叠，其思路非常简单可以概括为：\n加权平均聚合 \\rightarrow 维度变换 \\rightarrow 非线性激活数学形式如下：\n\n\\mathrm{H}^{(l+1)} = \\sigma\\left( \\tilde{D}^{-\\frac{1}{2}} \\tilde{\\mathrm{A}} \\tilde{D}^{-\\frac{1}{2}} \\mathrm{H}^{(l)} W^{(l)} \\right) \\tag{2.1}\n\\tilde{\\mathrm{A}} = \\mathrm{A} + I：带自环的邻接矩阵\n\\tilde{D}：\\tilde{A}的度矩阵，\\tilde{D} ^{-\\frac{1}{2}}意味着对于其中所有的非零元素都取正平方根的倒数；\n入度矩阵（有向图，指向该节点的边）：D^{\\text{in}}_{ii} = \\sum_j A_{ji}，\n出度矩阵（有向图，从该节点指出的边）：D^{\\text{out}}_{ii} = \\sum_j A_{ij}，\n\n\nH^{(l)}：第l层的节点特征， H^{(0)} = \\mathrm{X}；\nW^{(l)}：可训练权重矩阵；\n\\sigma：激活函数（如ReLU）。\n\nIII. 不同角度的Rationale可以说，这是通过推广卷积和其上的拉普拉斯算子到图上，来将其变换到频域来进行计算，【Xavier Bresson教授图神经网络系列讲座_bilibili，图神经网络理论基础-人大-魏哲巍_bilibili】这是合理的。也可以从深度学习的角度出发（当然这也是深度卷积网络），所谓浅层表示local，深层表示global信息，即低频率特征值和高频特征值。\n\n关注II部分中的公式.(2.1)中的部分：\n\\tilde{D}^{-\\frac{1}{2}} \\tilde{A} \\tilde{D}^{-\\frac{1}{2}} \\mathrm{H}^{(l)}本质上就是一个对于邻居节点和自身的加权平均，堆叠GNN的层可以看作是一个信息聚合的过程，如下图所示（有颜色的即为经过这次聚合后能够得到的信息）：\n\n这样的邻居聚合后共享参数其实蕴含了三个假设，\n\n第一，邻居节点和该节点的分类结果是相关的，这一假设与马尔科夫性质（Markov Property）相关，即一个节点的状态只依赖于其邻居节点的状态，也就会引出一些有关于马尔科夫毯（Markov blanket）的讨论，同时也引导人们看向诱导子图（Induced Graph）。\n第二，如果构建的是一个深度GNN，节点间的最短距离和相关性呈反比，即图信号处理中的平滑性假设（Smoothness Assumption）：图信号在局部区域内变化较小，也就是假设图信号的主要信息集中在低频部分，即图信号在局部区域内变化较小；\n第三，假设节点的特征和边的权重是独立的，即边的权重只反映节点之间的连接强度，而不直接依赖于节点特征，这也是为什么GCN原文用的是在社交图上的半监督的节点分类问题。可以说这三个假设是使得GCN这样的模式能够发挥作用的事后解释；也可以说是在发现其存在的问题之后的回顾，对于问题暂且先按下不表，先来看为什么他会有用，以及，是如何设计得更加符合神经网络工学的直觉的。\n\n这和图像卷积中的每次一个滑窗聚合其中的k\\times k的窗口内的像素点；抑或是信号与系统中的空域信号作倒序卷积，都有异曲同工之妙。\n重新定义图卷积（Graph Convolution）回顾一下卷积定义，其中t是连续时域变量，\\tau是窗口大小。\n(f * g)(t):= \\int_{\\infty}f( \\tau )g(t- \\tau )d \\tau离散版本，m 是窗口大小，n 是点列变量（离散时间），n\\in \\mathbb{Z}：\n(f*g)[n]=  \\sum_{m=-\\infty }^ {\\infty}f[m]g[n-m]=  \\sum _ {m=-\\infty }^ {\\infty }  f[n-m]g[m]卷积只是一种频域的分析方法，用滤波器g来筛选原来信号函数f的性质，那么，如何定义Graph上的卷积呢，我们只关注其中的任意一点n，观察对于它卷积的时候发生了什么：假设我们有以下输入信号 f 和卷积核 g：\n\n输入信号 f_n=[1,2,3,4]，索引范围为 0≤m≤3；\n卷积核 g_n=[1,2,1]，索引范围为 0≤m≤2。首先，将卷积核 g 翻转：g_{-m}=[1,2,1]，我们取其中非零的点来计算：\n当 n=3：\n卷积核覆盖的范围：n−m=3⇒m=1,2,3。\n有效范围：m=1,2,3。\n计算得到(f∗g)[3]=f[1]⋅g[2]+f[2]⋅g[1]+f[3]⋅g[0]=2⋅1+3⋅2+4⋅1=12即\\sum^{3}_{m=0} f[m] \\odot g_{-m}[m]，其中\\odot为哈德玛积，即逐个位置元素相乘。\n\n\n\n\n其上得到的是最后整个卷积后得到的函数的其中一个单位点，那么如果我们如果需要在图上定义什么是卷积，就需要定义什么是窗口？以及如何计算整个窗口内的各个元素的相加？\n对于单个节点，他的相邻的数据，显然，就是其相邻的节点，他们靠边来连接，因此很自然地，图卷积的定义就是\n\\tilde{A}\\mathrm{X}就这么简单。\n\n举栗.e.g.将矩阵可视化就是（假设是一个无向的图）：\n\n\n\n\n\\tilde{A}\n节点1\n节点2\n节点3\n节点4\n…\n\n\\mathrm{X}\n节点属性1\n属性2\n…\n\n\n\n\n节点1\n1\n0\n1\n0\n\n\n节点1\nblabla\nlbaba\nlabda\n\n\n节点2\n0\n1\n0\n0\n\n\\cdot\n节点2\nblala\nlbaba\n…\n\n\n节点3\n1\n0\n1\n1\n\n\n节点3\nblaa\nlba\n\n\n\n节点4\n0\n0\n1\n1\n\n\n节点4\nbabla\nlbdab\n\n\n\n…\n\n\n\n\n…\n\n…\n\n\n…\n\n\n\n\n将这个\\tilde{A} \\in \\mathbb{R}^{N \\times N}和\\mathrm{X} \\in \\mathbb{R}^{N \\times F}矩阵点积后可以得到更新后的\\mathrm{X}' \\in \\mathbb{R}^{N \\times F}\n其中（比如第一个节点的更新后的第一个属性，关注红色的行和列哈德玛积后相加），\n\\forall x'_i \\in \\mathrm{X}', x_j \\in N(j),x'_i = \\sum_{j} x_j.这里N(j)表示和原图中的节点x_j的1-hop邻居节点。\n\n那具体的步骤解释了，如何形式分析和定义呢？指路这家：图神经网络(GNN)入门之旅(三)-拉普拉斯矩阵与GCN - 知乎 (zhihu.com)；（看里面怎么定义拉普拉斯的就够了嗷，不要贪杯= ^ =）。简述就是希望模仿二维离散的拉普拉斯算子（如下），来推广图上的卷积和频谱分析：\n\\begin{pmatrix}  \n0 & 1  & 0  \\\\\n1 & -4  & 1 \\\\\n0 & 1  & 0 \\\\\n\\end{pmatrix}最最重要的是以下的这句话：\n“”假设具有 N 个节点的图 \\mathcal{G} ，此时图中每个节点的自由度至多为 N ，此时该图为完全图，即任意两个节点之间都有一条边连接，则对其中一个节点进行微扰，它可能变为图中任意一个节点。 \n此时以上定义的函数 f 不再是二维，而是 N 维向量： f=(f_1,f_2,...,f_N) ，其中 f_i 为函数 f 在图中节点 x_i 处的函数值。类比于二维函数 f(x,y) 在节点 (x,y) 处的值。 \n对 i 节点进行扰动，它可能变为任意一个与它相邻的节点 j∈N(i) , N(i) 表示节点 i 的一阶邻域节点。 \n我们上面已经知道拉普拉斯算子可以计算一个点到它所有自由度上微小扰动的增益，则通过图来表示就是任意一个节点 j 变化到节点 i 所带来的增益……“”\n也就是：图卷积是定义在图的边结构上的卷积，而 x_i \\sim p(X)，所有的节点都是来自于一个分布的采样；这其实也和其他的离散的信号定义保持了一致，但是其奥妙在于他是基于边的结构的卷积。\n\n但是显然地，我们会发现一个问题，在CV中，假设从函数的角度出发来看张量的变化，CNN(\\cdot) := f(x), x \\in \\mathbb{R}^{H \\times W \\times C} ，其输入和输出的张量形状是不一致的，即x^{(k)}= f(x^{(k-1)}), k≥1 的时候 (H^k \\times W^k) \\propto \\frac{1}{k} ，也就是如果不padding的话，CNN的张量随着网络深度的增加是越来越小的。但是GNN并非如此，GNN(\\cdot) := f(x), x \\in \\mathbb{R}^{N \\times F}, x^{(k)}= f(x^{(k-1)}), k≥1 的时候， N^k = N^{k-1},始终都是节点的个数，那自然会出现问题：也就是（当然并没有那么显然哦，只是我说的）GCN会遇到的，过渡平滑。\nIV. 图信号过渡平滑拉普拉斯平滑原理在图信号处理中，过渡平滑可通过图拉普拉斯矩阵量化，GCN传播一次的数学表达式为：\n\n\\mathcal{S}(f) = \\frac{1}{2} \\sum_{i,j=1}^n A_{ij} \\| f_i - f_j \\|^2 = f^\\top L f\nf_i, f_j，就是上述的Section.III的最后的引言部分的定义，对于每个节点的变换后的值；\nf \\in \\mathbb{R}^n，图信号向量；\nL = D - A， （姑且这样定义，也可以是归一化后的）组合拉普拉斯矩阵。因为拉普拉斯矩阵就是来刻画局部的平滑度，详见图像中运用了拉普拉斯核后的图像。\n\n平滑传播过程在图卷积网络中，多层传播导致的平滑效应可表示为：\n\nH^{(k+1)} = P H^{(k)} \\quad \\text{其中} \\quad P = \\tilde{D}^{-1/2}\\tilde{A}\\tilde{D}^{-1/2}对传播矩阵P（因为假设是拉普拉斯矩阵）进行特征分解：  \nP = U \\Lambda U^\\top经过K次传播后：  \nH^{(K)} = P^K H^{(0)} = U \\Lambda^K U^\\top H^{(0)}平滑动态特性那么自然地，从单个特征值的角度来看：\n\n高频分量衰减：\\lambda_i^K \\rightarrow 0 \\ (\\text{当}\\ |\\lambda_i| < 1)；\n低频分量保留：\\lambda_i^K \\rightarrow 1 \\ (\\text{当}\\ \\lambda_i \\approx 1)。\n\n过度平滑的数学描述当传播次数K \\rightarrow \\infty时，信号收敛至：  \n\\lim_{K \\to \\infty} P^K = \\frac{\\phi \\phi^\\top}{\\|\\phi\\|^2}其中\\phi是P的主特征向量，导致节点特征趋同：  \nH^{(\\infty)} \\propto \\phi \\cdot \\text{const}或者这样表示：\n\n设 h_i^{(k)} 表示节点 i 在第 k 层的特征；\n如果对于任意两个节点 i 和 j，有：\\lim_{k \\to \\infty} \\|h_i^{(k)} - h_j^{(k)}\\| = 0或者通过方差来刻画： \\text{Var}(H^{(k)}) \\to 0 \\quad \\text{当} \\quad k \\to \\infty\n\nV. 小结Kipf的GCN其实不是GCN的最初的频谱分析的流派的继承，而是做出了简单而且大胆的创新，虽然一开始是无向图，但是可以推广到有向图；\n其次是它的计算本质上是可以很快的，因为一切都取决于GPU上对于矩阵的点积操作的优化，但是，在大规模图上他的内存复杂消耗会到 O(N^2) 因为相当于直接存入邻接矩阵，而且稀疏图一般都是用链表或者是字典结构数据来存储的，因此不同存储的转化也存在加速的可能性；\n模型不具有随机性，没有独属于Graph的结构的数据增强和适合图的随机性对于方差的扩充。也就是，模型的泛化性不足 ———— 在OOD和存在分布偏移的数据上的泛化能力不足、对于动态图的适应能力较差。可以说这是由于他是transductive（直推）的，但是我不喜欢这种说辞，因为后续所谓提出inductive（归纳）方式解决了这个问题的GraphSAGE，实际上在动态图或者是分布差异的数据上的表现也不佳。\n虽然这也是其他所有的想要作更好的representation learning的模型的通病，这也有待后续的更多博客来探讨。博客文笔见疏，诸君评论多加指正。\n","tags":["Graph","GNN"]}]