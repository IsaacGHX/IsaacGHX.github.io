<!DOCTYPE html><html lang="en-us" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>正则表达式(RegEx)快速入门到进阶 | Isaac's Blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('/img/building_night.png');
 --light-background: url('/img/building_bright.png');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async src="/js/gitalk.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23lio2QITWez44KoAo',
 clientSecret: '447a665fc75c690be677605bfd0210a4e15396aa',
 repo: 'Comment4io',
 owner: 'IsaacGHX',
 admin: ['IsaacGHX'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {gitalk = new Gitalk({
 clientID: 'Ov23lio2QITWez44KoAo',
 clientSecret: '447a665fc75c690be677605bfd0210a4e15396aa',
 repo: 'Comment4io',
 owner: 'IsaacGHX',
 admin: ['IsaacGHX'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem"><a class="navBlock" href="/about/"><span class="navItemTitle">About</span></a></li><li class="navItem"><a class="navBlock" href="/contact/"><span class="navItemTitle">Contact</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>正则表达式(RegEx)快速入门到进阶</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-08-05T16:44:47.000Z" id="date"> 2025-08-06</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-08-21T10:21:09.027Z" id="updated"> 2025-08-21</time></div></span><br><span>Word Count: <div class="control">2.3k</div></span><br><span>Read Time: <div class="control">8 min</div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>正则表达式（Regular Expression，简称 Regex）是计算机科学中一个强大的工具，它使用一种专门的语法来查找、匹配和操作字符串中的模式。这是最最基础而且常用的模式匹配的工具啦~</p>
<p>最优的解决办法是先将请求询问大语言模型然后，万一，它错了，那请再根据自己的知识，去修改生成的模式匹配，那就效率max啦！</p>
<p><strong><em>注意注意再注意：正则匹配式也会随着版本的变化而变化，所以，实践出真知。</em></strong></p>
<hr>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="什么是正则表达式？"><a href="#什么是正则表达式？" class="headerlink" title="什么是正则表达式？"></a>什么是正则表达式？</h3><p>想象一下，你需要在文档中查找所有电话号码，但电话号码的格式多种多样，如 <code>010-12345678</code>、<code>(010)12345678</code> 或是 <code>13812345678</code>。手动查找无疑是低效且易出错的。正则表达式就是一种描述这种“模式”的语言，你可以构建一个单一的表达式来匹配所有这些格式。</p>
<p>简而言之，<strong>正则表达式是定义搜索模式的字符串</strong>。</p>
<h3 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h3><p>最简单的正则表达式就是普通字符。例如，正则表达式 <code>cat</code> 会在字符串 “The cat sat on the mat.” 中精确匹配到 “cat”。</p>
<h3 id="元字符-Metacharacters"><a href="#元字符-Metacharacters" class="headerlink" title="元字符 (Metacharacters)"></a>元字符 (Metacharacters)</h3><p>元字符是正则表达式中具有特殊含义的字符，它们是构建复杂模式的基石。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">点</td>
<td style="text-align:left">匹配除换行符 <code>\n</code> 之外的任意单个字符。</td>
<td style="text-align:left"><code>c.t</code></td>
<td style="text-align:left"><code>cat</code>, <code>cot</code>, <code>c@t</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">数字</td>
<td style="text-align:left">匹配任意一个数字 (等同于 <code>[0-9]</code>)。</td>
<td style="text-align:left"><code>\d\d</code></td>
<td style="text-align:left"><code>12</code>, <code>99</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left">非数字</td>
<td style="text-align:left">匹配任意一个非数字字符 (等同于 <code>[^0-9]</code>)。</td>
<td style="text-align:left"><code>\D\D</code></td>
<td style="text-align:left"><code>ab</code>, <code>!@</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">单词字符</td>
<td style="text-align:left">匹配任意一个字母、数字或下划线 (等同于 <code>[a-zA-Z0-9_]</code>)。</td>
<td style="text-align:left"><code>\w\w\w</code></td>
<td style="text-align:left"><code>cat</code>, <code>_12</code>, <code>A_b</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left">非单词字符</td>
<td style="text-align:left">匹配任意一个非字母、数字或下划线的字符。</td>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left"><code>@</code>, <code>!</code>, <code> </code> (空格)</td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">空白字符</td>
<td style="text-align:left">匹配任意一个空白字符，包括空格、制表符、换行符等。</td>
<td style="text-align:left"><code>cat\s</code></td>
<td style="text-align:left"><code>cat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left">非空白字符</td>
<td style="text-align:left">匹配任意一个非空白字符。</td>
<td style="text-align:left"><code>\S+</code></td>
<td style="text-align:left"><code>hello</code></td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">脱字符</td>
<td style="text-align:left">匹配字符串的开始位置。</td>
<td style="text-align:left"><code>^The</code></td>
<td style="text-align:left"><strong>The</strong> cat</td>
</tr>
<tr>
<td style="text-align:left">$$`</td>
<td style="text-align:left">美元符</td>
<td style="text-align:left">匹配字符串的结束位置。</td>
<td style="text-align:left">`end$$</td>
<td style="text-align:left">the <strong>end</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>\b</code></td>
<td style="text-align:left">单词边界</td>
<td style="text-align:left">匹配单词的开始或结束位置。</td>
<td style="text-align:left"><code>\bcat\b</code></td>
<td style="text-align:left">the <strong>cat</strong> sat</td>
</tr>
<tr>
<td style="text-align:left"><code>\B</code></td>
<td style="text-align:left">非单词边界</td>
<td style="text-align:left">匹配非单词边界。</td>
<td style="text-align:left"><code>\Bcat\B</code></td>
<td style="text-align:left">push<strong>cat</strong>kin</td>
</tr>
</tbody>
</table>
</div>
<h3 id="字符组-Character-Sets"><a href="#字符组-Character-Sets" class="headerlink" title="字符组 (Character Sets)"></a>字符组 (Character Sets)</h3><p>用方括号 <code>[]</code> 可以创建一个字符组，它会匹配方括号中包含的任意一个字符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">表达式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>[abc]</code></td>
<td style="text-align:left">匹配 <code>a</code>、<code>b</code> 或 <code>c</code> 中的任意一个。</td>
<td style="text-align:left"><code>[aeiou]</code> 匹配所有元音字母。</td>
</tr>
<tr>
<td style="text-align:left"><code>[^abc]</code></td>
<td style="text-align:left">否定字符组，匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 之外的任意一个字符。</td>
<td style="text-align:left"><code>[^0-9]</code> 匹配所有非数字字符。</td>
</tr>
<tr>
<td style="text-align:left"><code>[a-z]</code></td>
<td style="text-align:left">范围，匹配从 <code>a</code> 到 <code>z</code> 的任意一个小写字母。</td>
<td style="text-align:left"><code>[0-9a-fA-F]</code> 匹配一个十六进制数。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="量词-Quantifiers"><a href="#量词-Quantifiers" class="headerlink" title="量词 (Quantifiers)"></a>量词 (Quantifiers)</h3><p>量词用于指定一个模式需要出现的次数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">量词</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">示例</th>
<th style="text-align:left">匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">匹配前一个元素零次或多次。</td>
<td style="text-align:left"><code>ca*t</code></td>
<td style="text-align:left"><code>ct</code>, <code>cat</code>, <code>caaat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">匹配前一个元素一次或多次。</td>
<td style="text-align:left"><code>ca+t</code></td>
<td style="text-align:left"><code>cat</code>, <code>caaat</code></td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">匹配前一个元素零次或一次。</td>
<td style="text-align:left"><code>colou?r</code></td>
<td style="text-align:left"><code>color</code>, <code>colour</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&#123;n&#125;</code></td>
<td style="text-align:left">匹配前一个元素恰好 n 次。</td>
<td style="text-align:left"><code>\d&#123;3&#125;</code></td>
<td style="text-align:left"><code>123</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&#123;n,&#125;</code></td>
<td style="text-align:left">匹配前一个元素至少 n 次。</td>
<td style="text-align:left"><code>\d&#123;2,&#125;</code></td>
<td style="text-align:left"><code>12</code>, <code>123</code>, <code>1234</code></td>
</tr>
<tr>
<td style="text-align:left"><code>&#123;n,m&#125;</code></td>
<td style="text-align:left">匹配前一个元素至少 n 次，至多 m 次。</td>
<td style="text-align:left"><code>\w&#123;3,5&#125;</code></td>
<td style="text-align:left"><code>abc</code>, <code>abcd</code>, <code>abcde</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="贪婪与非贪婪匹配"><a href="#贪婪与非贪婪匹配" class="headerlink" title="贪婪与非贪婪匹配"></a>贪婪与非贪婪匹配</h3><p>默认情况下，量词是<strong>贪婪的 (Greedy)</strong>，意味着它们会尽可能多地匹配字符。</p>
<ul>
<li><strong>示例</strong>：对于字符串 <code>&quot;&lt;div&gt;hello&lt;/div&gt;&quot;</code>，表达式 <code>&lt;div&gt;.*&lt;/div&gt;</code> 会匹配整个字符串。</li>
</ul>
<p>在量词后面加上一个问号 <code>?</code> 可以将其变为<strong>非贪婪 (Non-greedy) 或懒惰 (Lazy)</strong> 模式，它会尽可能少地匹配字符。</p>
<ul>
<li><strong>示例</strong>：对于相同字符串，表达式 <code>&lt;div&gt;.*?&lt;/div&gt;</code> 只会匹配到 <code>&lt;div&gt;hello&lt;/div&gt;</code>。</li>
</ul>
<hr>
<h2 id="进阶指南"><a href="#进阶指南" class="headerlink" title="进阶指南"></a>进阶指南</h2><h3 id="分组与捕获-Grouping-and-Capturing"><a href="#分组与捕获-Grouping-and-Capturing" class="headerlink" title="分组与捕获 (Grouping and Capturing)"></a>分组与捕获 (Grouping and Capturing)</h3><p>使用圆括号 <code>()</code> 可以创建一个分组。分组有两个主要作用：</p>
<ol>
<li><strong>作为一个整体进行量化</strong>：<code>(ab)+</code> 会匹配 <code>ab</code>、<code>abab</code>、<code>ababab</code> 等。</li>
<li><strong>捕获内容</strong>：匹配到的内容会被捕获到一个编号的组中，可以被后续引用。组的编号从 1 开始，从左到右依次递增。</li>
</ol>
<p><strong>非捕获组 <code>(?:...)</code></strong></p>
<p>有时你只需要分组的功能而不需要捕获内容，此时可以使用非捕获组 <code>(?:...)</code>，这样可以提高性能，并且不占用组的编号。</p>
<ul>
<li><strong>示例</strong>：<code>(?:https?://)?(www\.\w+\.\w+)</code><ul>
<li><code>(?:https?://)</code>: 匹配 <code>http://</code> 或 <code>https://</code>，但不捕获它。</li>
<li><code>(www\.\w+\.\w+)</code>: 捕获网站域名，如 <code>www.example.com</code>。</li>
</ul>
</li>
</ul>
<h3 id="断言-Assertions-环视-零宽断言"><a href="#断言-Assertions-环视-零宽断言" class="headerlink" title="断言 (Assertions) - 环视/零宽断言"></a>断言 (Assertions) - 环视/零宽断言</h3><p>断言（也称环视或零宽断言）是一种特殊的结构，它只匹配一个位置，而不消耗任何字符。它就像一个条件，要求当前位置的前面或后面必须满足某种模式，但这个模式本身不会成为匹配结果的一部分。</p>
<table style="border-collapse: collapse; width: 100%;">
  <thead>
    <tr style="border-bottom: 2px solid #ddd;">
      <th style="padding: 8px 12px; text-align: left; min-width: 120px; white-space: nowrap;">类型</th>
      <th style="padding: 8px 12px; text-align: left; min-width: 100px; white-space: nowrap;">表达式</th>
      <th style="padding: 8px 12px; text-align: left; min-width: 200px;">描述</th>
      <th style="padding: 8px 12px; text-align: left; min-width: 400px; white-space: nowrap;">示例</th>
    </tr>
  </thead>
  <tbody>
    <tr style="border-bottom: 1px solid #eee;">
      <td><strong>正向先行断言</strong></td>
      <td><code>(?=...)</code></td>
      <td>要求当前位置的右侧必须能匹配<code>...</code>的模式。</td>
      <td><code>Windows (?=NT|XP)</code> 匹配"Windows"，但仅当其后是"NT"或"XP"时。</td>
    </tr>
    <tr style="border-bottom: 1px solid #eee;">
      <td><strong>负向先行断言</strong></td>
      <td><code>(?!...)</code></td>
      <td>要求当前位置的右侧不能匹配<code>...</code>的模式。</td>
      <td><code>Windows (?!NT|XP)</code> 匹配"Windows"，但仅当其后不是"NT"或"XP"时。</td>
    </tr>
    <tr style="border-bottom: 1px solid #eee;">
      <td><strong>正向后行断言</strong></td>
      <td><code>(?&lt;=...)</code></td>
      <td>要求当前位置的左侧必须能匹配<code>...</code>的模式。</td>
      <td><code>(?&lt;=USD)\d+</code> 匹配数字，但仅当其前面是"USD"时。</td>
    </tr>
    <tr>
      <td><strong>负向后行断言</strong></td>
      <td><code>(?&lt;!...)</code></td>
      <td>要求当前位置的左侧不能匹配<code>...</code>的模式。</td>
      <td><code>(?&lt;!USD)\d+</code> 匹配数字，但仅当其前面不是"USD"时。</td>
    </tr>
  </tbody>
</table>

<p><strong>注意</strong>：部分语言或引擎对后行断言的支持不完整。</p>
<h3 id="反向引用-Backreferences"><a href="#反向引用-Backreferences" class="headerlink" title="反向引用 (Backreferences)"></a>反向引用 (Backreferences)</h3><p>反向引用允许你在正则表达式的后面部分引用前面捕获到的分组。通常使用 <code>\1</code>, <code>\2</code>, <code>\3</code> 等来引用第一个、第二个、第三个捕获组。</p>
<ul>
<li><strong>示例</strong>：查找重复的单词<ul>
<li>表达式：<code>\b(\w+)\s+\1\b</code></li>
<li><code>\b(\w+)\b</code>: 匹配并捕获一个单词。</li>
<li><code>\s+</code>: 匹配一个或多个空白符。</li>
<li><code>\1</code>: 引用第一个捕获组（即前面捕获的单词）。</li>
<li>这个表达式可以匹配 “hello hello” 或 “go go”。</li>
</ul>
</li>
</ul>
<h3 id="模式修饰符-Modifiers"><a href="#模式修饰符-Modifiers" class="headerlink" title="模式修饰符 (Modifiers)"></a>模式修饰符 (Modifiers)</h3><p>模式修饰符可以改变正则表达式的默认行为。它们通常放在整个表达式的末尾（例如 <code>/.../i</code>）或在表达式内部（例如 <code>(?i)</code>）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">修饰符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>i</code></td>
<td style="text-align:left">忽略大小写 (Case-Insensitive)</td>
<td style="text-align:left">使匹配不区分大小写。</td>
</tr>
<tr>
<td style="text-align:left"><code>g</code></td>
<td style="text-align:left">全局匹配 (Global)</td>
<td style="text-align:left">查找所有匹配项，而不是在找到第一个后就停止。</td>
</tr>
<tr>
<td style="text-align:left"><code>m</code></td>
<td style="text-align:left">多行模式 (Multiline)</td>
<td style="text-align:left">使 <code>^</code> 和 <code>$</code> 能够匹配每一行的开始和结束，而不仅仅是整个字符串的开始和结束。</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h2 id="常用场景实战"><a href="#常用场景实战" class="headerlink" title="常用场景实战"></a>常用场景实战</h2><h3 id="表单验证：校验邮箱地址"><a href="#表单验证：校验邮箱地址" class="headerlink" title="表单验证：校验邮箱地址"></a>表单验证：校验邮箱地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,&#125;$<br></code></pre></td></tr></table></figure>
<ul>
<li><code>^</code>: 字符串开始。</li>
<li><code>[a-zA-Z0-9._%+-]+</code>: 用户名部分，包含字母、数字和一些特殊字符。</li>
<li><code>@</code>: 分隔符。</li>
<li><code>[a-zA-Z0-9.-]+</code>: 域名部分。</li>
<li><code>\.</code>: 匹配点 <code>.</code>。</li>
<li><code>[a-zA-Z]&#123;2,&#125;</code>: 顶级域名，至少两个字母。</li>
<li><code>$</code>: 字符串结束。</li>
</ul>
<h3 id="数据提取：抓取网页中的链接"><a href="#数据提取：抓取网页中的链接" class="headerlink" title="数据提取：抓取网页中的链接"></a>数据提取：抓取网页中的链接</h3><p>假设我们有以下 HTML 代码：<br><code>&lt;a href=&quot;https://example.com&quot;&gt;Example 1&lt;/a&gt;</code><br><code>&lt;a href=&quot;http://test.org&quot;&gt;Test 2&lt;/a&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">&lt;a\s+href=&quot;([^&quot;]+)&quot;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>&lt;a\s+href=&quot;</code>: 匹配 <code>&lt;a&gt;</code> 标签的 <code>href</code> 属性。</li>
<li><code>([^&quot;]+)</code>: 捕获 <code>href</code> 属性的值（即 URL）。<code>[^&quot;]+</code> 匹配一个或多个非双引号的字符。</li>
</ul>
<h3 id="日志分析：筛选特定错误信息"><a href="#日志分析：筛选特定错误信息" class="headerlink" title="日志分析：筛选特定错误信息"></a>日志分析：筛选特定错误信息</h3><p>假设日志格式为 <code>[YYYY-MM-DD HH:MM:SS] [LEVEL] Message</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs log">[2025-08-06 01:42:00] [INFO] User logged in.<br>[2025-08-06 01:43:15] [ERROR] Database connection failed.<br>[2025-08-06 01:44:00] [DEBUG] Processing request.<br></code></pre></td></tr></table></figure>
<p>要只匹配 ERROR 级别的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">^\[\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125; \d&#123;2&#125;:\d&#123;2&#125;:\d&#123;2&#125;\] \[ERROR\] .*$<br></code></pre></td></tr></table></figure>
<ul>
<li><code>^\[...\]</code>: 匹配时间戳部分。注意 <code>[</code> 需要转义。</li>
<li><code>\[ERROR\]</code>: 精确匹配 <code>[ERROR]</code>。</li>
<li><code>.*</code>: 匹配该行剩余的任意内容。</li>
<li><code>$</code>: 匹配行尾。</li>
</ul>
<hr>
<h2 id="实用工具与资源"><a href="#实用工具与资源" class="headerlink" title="实用工具与资源"></a>实用工具与资源</h2><p>学习正则表达式最好的方法就是不断练习。以下是一些非常有用的在线工具和资源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://regex101.com/"><strong>Regex101</strong></a>: 一个功能强大的在线正则表达式测试、调试和学习网站。它会详细分析你的表达式，并提供实时匹配高亮。</li>
<li><a target="_blank" rel="noopener" href="https://regexr.com/"><strong>RegExr</strong></a>: 另一个优秀的在线正则表达式测试工具，界面友好，提供丰富的社区模式库。</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/"><strong>MDN Web Docs (Mozilla)</strong></a>: 如果你在 JavaScript 中使用正则表达式，MDN 提供了详尽的文档和教程。</li>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/re.html"><strong>Python <code>re</code> module documentation</strong></a>: Python 官方文档是学习 Python 中正则用法的权威指南。</li>
</ul>
<p>希望这篇教程能帮助你开启正则表达式的学习之旅！记住，熟能生巧，多加练习，你很快就能运用自如。</p>
<div class="github-star-promo"><!-- [新] 现在只有一个 promo-text 的 div--><div class="promo-text">如果觉得有用欢迎给我的项目加一个 ⭐<!-- [新] iframe 直接放在文字中间--><iframe src="https://ghbtns.com/github-btn.html?user=IsaacGHX&amp;repo=IsaacGHX.github.io&amp;type=star&amp;count=true&amp;size=large" frameborder="0" scrolling="0" width="170" height="30" title="Star this project on GitHub"></iframe> =w=/</div></div><div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2025/08/08/solutions/Hand-made-Solution-and-CoT-for-AIME25/">← Next Hand-made Solution and CoT for AIME25'(浅浅手撕 AIME25')</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2025/08/05/fast_startup/%E8%B6%85%E5%B8%B8%E7%94%A8-Linux-%E5%91%BD%E4%BB%A4%E5%90%88%E8%BE%91/">超常用 Linux 命令合辑 Prev →</a></div></div></div><div id="comments"><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/2.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/about">Isaac IPF</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是正则表达式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">基本匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-Metacharacters"><span class="toc-number">1.1.3.</span> <span class="toc-text">元字符 (Metacharacters)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BB%84-Character-Sets"><span class="toc-number">1.1.4.</span> <span class="toc-text">字符组 (Character Sets)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D-Quantifiers"><span class="toc-number">1.1.5.</span> <span class="toc-text">量词 (Quantifiers)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D"><span class="toc-number">1.1.6.</span> <span class="toc-text">贪婪与非贪婪匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97"><span class="toc-number">1.2.</span> <span class="toc-text">进阶指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%B8%8E%E6%8D%95%E8%8E%B7-Grouping-and-Capturing"><span class="toc-number">1.2.1.</span> <span class="toc-text">分组与捕获 (Grouping and Capturing)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80-Assertions-%E7%8E%AF%E8%A7%86-%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">断言 (Assertions) - 环视&#x2F;零宽断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8-Backreferences"><span class="toc-number">1.2.3.</span> <span class="toc-text">反向引用 (Backreferences)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6-Modifiers"><span class="toc-number">1.2.4.</span> <span class="toc-text">模式修饰符 (Modifiers)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">常用场景实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%EF%BC%9A%E6%A0%A1%E9%AA%8C%E9%82%AE%E7%AE%B1%E5%9C%B0%E5%9D%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">表单验证：校验邮箱地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%EF%BC%9A%E6%8A%93%E5%8F%96%E7%BD%91%E9%A1%B5%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">数据提取：抓取网页中的链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%EF%BC%9A%E7%AD%9B%E9%80%89%E7%89%B9%E5%AE%9A%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">日志分析：筛选特定错误信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%B5%84%E6%BA%90"><span class="toc-number">1.4.</span> <span class="toc-text">实用工具与资源</span></a></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/IsaacGHX">Isaac_GHX </a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr><wbr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>